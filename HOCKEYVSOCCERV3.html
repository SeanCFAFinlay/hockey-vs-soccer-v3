<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<!-- Version 3 of Hockey vs Soccer TD -->
<title>üèí Hockey vs Soccer ‚öΩ TD ‚Äì Version 3</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<style>
:root {
  --safe-top: env(safe-area-inset-top);
  --safe-bottom: env(safe-area-inset-bottom);
  --ice: #00d4ff;
  --grass: #22c55e;
  --gold: #ffd700;
  --red: #ef4444;
  --bg: #0a0c12;
}
* { margin:0; padding:0; box-sizing:border-box; -webkit-tap-highlight-color:transparent; -webkit-touch-callout:none; -webkit-user-select:none; user-select:none; }
html, body { width:100%; height:100%; overflow:hidden; font-family:-apple-system,BlinkMacSystemFont,sans-serif; background:var(--bg); color:#fff; position:fixed; touch-action:none; }

.screen { display:none; height:100%; }
.screen.active { display:flex; flex-direction:column; }

#menuScreen { background:linear-gradient(135deg, #0a0a1a 0%, #1a1a2e 100%); justify-content:center; align-items:center; padding:20px; padding-top:calc(20px + var(--safe-top)); }
.logo { text-align:center; margin-bottom:40px; }
.logo-icons { font-size:3.5rem; margin-bottom:10px; }
.logo h1 { font-size:1.8rem; font-weight:800; }
.logo h1 .ice { color:var(--ice); }
.logo h1 .grass { color:var(--grass); }
.logo p { color:rgba(255,255,255,0.4); font-size:0.9rem; letter-spacing:4px; margin-top:8px; }
.menu-cards { display:flex; flex-direction:column; gap:16px; width:100%; max-width:380px; }
.menu-card { display:flex; align-items:center; gap:16px; padding:22px; background:rgba(255,255,255,0.05); border:2px solid rgba(255,255,255,0.1); border-radius:20px; transition:all .2s; }
.menu-card:active { transform:scale(0.98); }
.menu-card.hockey { border-color:rgba(0,212,255,0.3); }
.menu-card.hockey:active { border-color:var(--ice); box-shadow:0 0 30px rgba(0,212,255,0.3); }
.menu-card.soccer { border-color:rgba(34,197,94,0.3); }
.menu-card.soccer:active { border-color:var(--grass); box-shadow:0 0 30px rgba(34,197,94,0.3); }
.menu-card-icon { font-size:3rem; }
.menu-card h3 { font-size:1.3rem; font-weight:700; }
.menu-card.hockey h3 { color:var(--ice); }
.menu-card.soccer h3 { color:var(--grass); }
.menu-card p { font-size:0.85rem; color:rgba(255,255,255,0.5); margin-top:4px; }
.menu-card-arrow { margin-left:auto; font-size:1.5rem; opacity:0.3; }

#mapScreen { background:linear-gradient(135deg, #0a0a1a 0%, #1a1a2e 100%); padding:16px; padding-top:calc(16px + var(--safe-top)); padding-bottom:calc(16px + var(--safe-bottom)); }
.map-header { display:flex; align-items:center; gap:12px; margin-bottom:20px; }
.back-btn { width:44px; height:44px; background:rgba(255,255,255,0.1); border:none; border-radius:12px; color:#fff; font-size:1.3rem; }
.map-title { font-size:1.4rem; font-weight:700; }
.map-grid { display:grid; grid-template-columns:repeat(2,1fr); gap:12px; overflow-y:auto; flex:1; -webkit-overflow-scrolling:touch; }
.map-card { background:rgba(255,255,255,0.05); border:2px solid rgba(255,255,255,0.1); border-radius:16px; padding:14px; text-align:center; }
.map-card:active { border-color:var(--c); }
.map-card-icon { font-size:2rem; margin-bottom:6px; }
.map-card-name { font-size:1rem; font-weight:700; color:var(--c); }
.map-card-info { font-size:0.75rem; color:rgba(255,255,255,0.5); margin:4px 0 8px; }
.map-stars { display:flex; justify-content:center; gap:3px; }
.map-stars span { font-size:0.8rem; opacity:0.2; }
.map-stars span.on { opacity:1; }
.map-best { font-size:0.7rem; color:rgba(255,255,255,0.6); margin-top:4px; }
.map-lock { font-size:0.7rem; color:rgba(255,255,255,0.5); margin-top:4px; }
.map-card.locked { opacity:0.4; pointer-events:none; }
.map-card.last-played { border-color:var(--c); box-shadow:0 0 16px color-mix(in srgb, var(--c) 35%, transparent); }

.menu-settings { margin-top:24px; display:flex; flex-direction:column; gap:10px; align-items:center; }
.setting-row { width:100%; max-width:380px; display:flex; align-items:center; justify-content:space-between; background:rgba(255,255,255,0.06); border:1px solid rgba(255,255,255,0.1); border-radius:14px; padding:10px 14px; }
.setting-row span { font-size:0.8rem; color:rgba(255,255,255,0.6); }
.setting-btn { background:rgba(255,255,255,0.1); border:1px solid rgba(255,255,255,0.2); color:#fff; border-radius:10px; padding:6px 10px; font-size:0.75rem; font-weight:700; }
.setting-btn.active { background:rgba(255,255,255,0.25); }
.setting-speed { display:flex; gap:6px; }

#gameScreen { background:#000; }
.hud { position:absolute; top:0; left:0; right:0; z-index:100; padding:10px 12px; padding-top:calc(10px + var(--safe-top)); display:flex; justify-content:space-between; align-items:center; background:linear-gradient(to bottom, rgba(0,0,0,0.85) 0%, transparent 100%); pointer-events:none; }
.hud > * { pointer-events:auto; }
.hud-left { display:flex; align-items:center; gap:10px; }
.hud-menu { width:40px; height:40px; background:rgba(0,0,0,0.7); border:1px solid rgba(255,255,255,0.2); border-radius:10px; color:#fff; font-size:1.2rem; backdrop-filter:blur(10px); }
.hud-wave { background:rgba(0,0,0,0.7); padding:8px 14px; border-radius:20px; font-size:0.85rem; font-weight:600; border:1px solid rgba(255,255,255,0.15); backdrop-filter:blur(10px); }
.hud-right { display:flex; gap:8px; }
.hud-stat { display:flex; align-items:center; gap:5px; background:rgba(0,0,0,0.7); padding:8px 12px; border-radius:20px; font-size:0.85rem; font-weight:700; border:1px solid rgba(255,255,255,0.15); backdrop-filter:blur(10px); }
.hud-stat.money { color:var(--gold); }
.hud-stat.lives { color:var(--red); }
.hud-stat.score { color:var(--grass); }

.canvas-wrap { position:absolute; inset:0; }
#gameCanvas { width:100%; height:100%; display:block; }

.cam-btns { position:absolute; right:12px; top:50%; transform:translateY(-50%); display:flex; flex-direction:column; gap:8px; z-index:50; }
.cam-btn { width:44px; height:44px; background:rgba(0,0,0,0.7); border:1px solid rgba(255,255,255,0.2); border-radius:12px; color:#fff; font-size:1.3rem; backdrop-filter:blur(10px); }

.bottom-ui { position:absolute; bottom:0; left:0; right:0; z-index:100; padding-bottom:var(--safe-bottom); background:linear-gradient(to top, rgba(0,0,0,0.95) 0%, rgba(0,0,0,0.8) 80%, transparent 100%); }
.tower-bar { display:flex; gap:8px; padding:12px; overflow-x:auto; -webkit-overflow-scrolling:touch; }
.tower-bar::-webkit-scrollbar { display:none; }
.tower-btn { flex-shrink:0; width:68px; background:rgba(255,255,255,0.08); border:2px solid rgba(255,255,255,0.15); border-radius:14px; padding:8px 4px; text-align:center; backdrop-filter:blur(10px); }
.tower-btn.selected { border-color:var(--c); background:rgba(255,255,255,0.15); box-shadow:0 0 20px color-mix(in srgb, var(--c) 50%, transparent); transform:translateY(-4px); }
.tower-btn.disabled { opacity:0.35; }
.tower-btn-icon { font-size:1.5rem; }
.tower-btn-name { font-size:0.6rem; color:rgba(255,255,255,0.6); margin:3px 0 2px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
.tower-btn-cost { font-size:0.8rem; font-weight:700; color:var(--gold); }

.action-bar { display:flex; gap:6px; padding:0 12px 12px; }
.action-btn { flex:1; padding:12px 6px; border:none; border-radius:10px; font-size:0.8rem; font-weight:700; backdrop-filter:blur(10px); }
.speed-btns { display:flex; gap:4px; }
.speed-btn { width:40px; background:rgba(255,255,255,0.1); border:1px solid rgba(255,255,255,0.2); border-radius:8px; color:rgba(255,255,255,0.5); font-weight:700; font-size:0.85rem; }
.speed-btn.active { background:rgba(0,212,255,0.3); color:var(--ice); border-color:var(--ice); }
.sell-btn { background:rgba(239,68,68,0.2); color:var(--red); border:1px solid rgba(239,68,68,0.4); }
.sell-btn.active { background:var(--red); color:#fff; }
.start-btn { flex:2; background:var(--grass); color:#fff; border:none; font-size:0.9rem; }
.start-btn:disabled { background:#444; color:#666; }

.upgrade-sheet { position:fixed; bottom:0; left:0; right:0; background:rgba(15,15,25,0.98); border-top:2px solid var(--gold); padding:16px; padding-bottom:calc(16px + var(--safe-bottom)); z-index:200; transform:translateY(100%); transition:transform .25s ease-out; backdrop-filter:blur(20px); border-radius:20px 20px 0 0; }
.upgrade-sheet.show { transform:translateY(0); }
.upgrade-handle { width:36px; height:4px; background:rgba(255,255,255,0.3); border-radius:2px; margin:0 auto 14px; }
.upgrade-header { display:flex; align-items:center; gap:10px; margin-bottom:14px; }
.upgrade-icon { font-size:1.8rem; }
.upgrade-info h3 { font-size:1.1rem; font-weight:700; }
.upgrade-info p { font-size:0.8rem; color:rgba(255,255,255,0.5); }
.upgrade-stats { display:flex; gap:10px; margin-bottom:14px; }
.upgrade-stat { flex:1; background:rgba(255,255,255,0.05); padding:10px 8px; border-radius:10px; text-align:center; }
.upgrade-stat-label { font-size:0.65rem; color:rgba(255,255,255,0.4); margin-bottom:2px; }
.upgrade-stat-value { font-size:1rem; font-weight:700; }
.upgrade-stat-next { font-size:0.75rem; color:var(--grass); }
.upgrade-btns { display:flex; gap:10px; }
.upgrade-btn { flex:1; padding:14px; border:none; border-radius:12px; font-size:0.95rem; font-weight:700; }
.upgrade-btn.sell { background:rgba(239,68,68,0.2); color:var(--red); }
.upgrade-btn.do-upgrade { background:var(--gold); color:#000; }
.upgrade-btn:disabled { background:#333; color:#555; }

.modal-overlay { position:fixed; inset:0; background:rgba(0,0,0,0.9); z-index:300; display:none; align-items:center; justify-content:center; padding:20px; }
.modal-overlay.show { display:flex; }
.modal { background:rgba(20,20,30,0.98); padding:28px; border-radius:24px; text-align:center; width:100%; max-width:300px; border:2px solid; }
.modal-icon { font-size:3.5rem; margin-bottom:12px; }
.modal h2 { font-size:1.6rem; font-weight:800; margin-bottom:16px; }
.modal.win h2 { color:var(--grass); }
.modal.win { border-color:var(--grass); }
.modal.lose h2 { color:var(--red); }
.modal.lose { border-color:var(--red); }
.modal-stats { display:flex; justify-content:center; gap:28px; margin-bottom:20px; }
.modal-stat-val { font-size:1.8rem; font-weight:800; color:var(--gold); }
.modal-stat-label { font-size:0.75rem; color:rgba(255,255,255,0.5); }
.modal-btn { width:100%; padding:14px; border:none; border-radius:12px; font-size:1rem; font-weight:700; color:#fff; }
.modal.win .modal-btn { background:var(--grass); }
.modal.lose .modal-btn { background:var(--red); }

@media (min-width:768px) {
  .tower-btn { width:80px; padding:10px 6px; }
  .tower-btn-icon { font-size:1.8rem; }
  .tower-btn-name { font-size:0.7rem; }
  .action-btn { padding:14px 10px; font-size:0.9rem; }
}
</style>
</head>
<body>

<div id="menuScreen" class="screen active">
  <div class="logo">
    <div class="logo-icons">üèí ‚ö° ‚öΩ</div>
    <h1><span class="ice">HOCKEY</span> vs <span class="grass">SOCCER</span></h1>
    <p>TOWER DEFENSE 3D</p>
  </div>
  <div class="menu-cards">
    <div class="menu-card hockey" onclick="selectTheme('hockey')">
      <div class="menu-card-icon">üèí</div>
      <div><h3>Hockey Arena</h3><p>Defend on ice ‚Ä¢ Stop the pucks!</p></div>
      <div class="menu-card-arrow">‚Ä∫</div>
    </div>
    <div class="menu-card soccer" onclick="selectTheme('soccer')">
      <div class="menu-card-icon">‚öΩ</div>
      <div><h3>Soccer Stadium</h3><p>Defend on grass ‚Ä¢ Block the balls!</p></div>
      <div class="menu-card-arrow">‚Ä∫</div>
    </div>
  </div>
  <div class="menu-settings">
    <div class="setting-row">
      <span>Sound</span>
      <button class="setting-btn" id="sfxToggle">SFX: On</button>
    </div>
    <div class="setting-row">
      <span>Default Speed</span>
      <div class="setting-speed">
        <button class="setting-btn speed-setting" data-speed="1">1√ó</button>
        <button class="setting-btn speed-setting" data-speed="2">2√ó</button>
        <button class="setting-btn speed-setting" data-speed="3">3√ó</button>
      </div>
    </div>
  </div>
</div>

<div id="mapScreen" class="screen">
  <div class="map-header">
    <button class="back-btn" onclick="showScreen('menuScreen')">‚Äπ</button>
    <h2 class="map-title" id="mapTitle">Select Arena</h2>
  </div>
  <div class="map-grid" id="mapGrid"></div>
</div>

<div id="gameScreen" class="screen">
  <div class="hud">
    <div class="hud-left">
      <button class="hud-menu" onclick="exitGame()">‚úï</button>
      <div class="hud-wave">üåä <span id="waveNum">0</span>/<span id="waveMax">20</span></div>
    </div>
    <div class="hud-right">
      <div class="hud-stat money">üí∞<span id="moneyVal">500</span></div>
      <div class="hud-stat lives">‚ù§Ô∏è<span id="livesVal">20</span></div>
      <div class="hud-stat score">‚≠ê<span id="scoreVal">0</span></div>
    </div>
  </div>
  
  <div class="canvas-wrap"><canvas id="gameCanvas"></canvas></div>
  
  <div class="cam-btns">
    <button class="cam-btn" onclick="zoomIn()">+</button>
    <button class="cam-btn" onclick="zoomOut()">‚àí</button>
    <button class="cam-btn" onclick="resetCam()">‚ü≤</button>
  </div>
  
  <div class="bottom-ui">
    <div class="tower-bar" id="towerBar"></div>
    <div class="action-bar">
      <div class="speed-btns">
        <button class="action-btn speed-btn active" data-speed="1">1√ó</button>
        <button class="action-btn speed-btn" data-speed="2">2√ó</button>
        <button class="action-btn speed-btn" data-speed="3">3√ó</button>
      </div>
      <button class="action-btn sell-btn" id="sellBtn" onclick="toggleSell()">SELL</button>
      <button class="action-btn start-btn" id="startBtn" onclick="startWave()">‚ñ∂ START</button>
    </div>
  </div>
</div>

<div class="upgrade-sheet" id="upgradeSheet">
  <div class="upgrade-handle"></div>
  <div class="upgrade-header">
    <div class="upgrade-icon" id="upIcon">üèí</div>
    <div class="upgrade-info"><h3 id="upName">Tower</h3><p id="upLevel">Level 1</p></div>
  </div>
  <div class="upgrade-stats">
    <div class="upgrade-stat"><div class="upgrade-stat-label">DMG</div><div class="upgrade-stat-value" id="upDmg">50</div><div class="upgrade-stat-next" id="upDmgNext">‚Üí75</div></div>
    <div class="upgrade-stat"><div class="upgrade-stat-label">RNG</div><div class="upgrade-stat-value" id="upRng">3.0</div><div class="upgrade-stat-next" id="upRngNext">‚Üí3.5</div></div>
    <div class="upgrade-stat"><div class="upgrade-stat-label">RATE</div><div class="upgrade-stat-value" id="upRate">1.0</div><div class="upgrade-stat-next" id="upRateNext">‚Üí1.2</div></div>
  </div>
  <div class="upgrade-btns">
    <button class="upgrade-btn sell" onclick="sellTower()">Sell $<span id="upSell">60</span></button>
    <button class="upgrade-btn do-upgrade" id="upBtn" onclick="doUpgrade()">Upgrade $<span id="upCost">80</span></button>
  </div>
</div>

<div class="modal-overlay" id="winModal"><div class="modal win"><div class="modal-icon">üèÜ</div><h2>VICTORY!</h2><div class="modal-stats"><div><div class="modal-stat-val" id="winScore">0</div><div class="modal-stat-label">Score</div></div><div><div class="modal-stat-val" id="winWaves">0</div><div class="modal-stat-label">Waves</div></div></div><button class="modal-btn" onclick="closeModal('win')">Continue</button></div></div>
<div class="modal-overlay" id="loseModal"><div class="modal lose"><div class="modal-icon">üíÄ</div><h2>DEFEATED</h2><div class="modal-stats"><div><div class="modal-stat-val" id="loseWave">0</div><div class="modal-stat-label">Wave</div></div><div><div class="modal-stat-val" id="loseScore">0</div><div class="modal-stat-label">Score</div></div></div><button class="modal-btn" onclick="closeModal('lose')">Try Again</button></div></div>

<script>
const THEMES = {
  hockey: {
    name: 'Hockey Arena', icon: 'üèí', color: '#00d4ff',
    groundColor: 0xe0f0f8, pathColor: 0xc8dce8, envColor: 0x0a1520,
    maps: [
      { name: 'Practice Rink', cols: 18, rows: 11, waves: 15, money: 650, lives: 20, diff: 1 },
      { name: 'Local Arena', cols: 20, rows: 12, waves: 20, money: 700, lives: 18, diff: 2 },
      { name: 'College Ice', cols: 22, rows: 13, waves: 25, money: 750, lives: 15, diff: 3 },
      { name: 'Pro Stadium', cols: 24, rows: 14, waves: 30, money: 850, lives: 12, diff: 4 },
      { name: 'Stanley Cup', cols: 26, rows: 15, waves: 40, money: 1000, lives: 10, diff: 5 },
      { name: 'Frozen Lake', cols: 28, rows: 16, waves: 45, money: 1200, lives: 8, diff: 6 },
      { name: 'Winter Classic', cols: 30, rows: 17, waves: 50, money: 1300, lives: 7, diff: 7 },
      { name: 'World Championships', cols: 32, rows: 18, waves: 55, money: 1400, lives: 6, diff: 8 },
      { name: 'All‚ÄëStar Arena', cols: 34, rows: 19, waves: 60, money: 1500, lives: 5, diff: 9 },
      { name: 'Hall of Fame', cols: 36, rows: 20, waves: 65, money: 1600, lives: 4, diff: 10 }
    ],
    towers: [
      { id:'t1', nm:'Slap Shot', icon:'üèí', cost:80, clr:'#00d4ff', dmg:[25,40,60,90], rng:[2.8,3.2,3.6,4.1], rate:[1.2,1.4,1.7,2.0], up:[60,100,170], projectile:'puck' },
      { id:'t2', nm:'Sniper', icon:'üéØ', cost:150, clr:'#ef4444', dmg:[70,110,165,250], rng:[4.5,5.0,5.6,6.2], rate:[0.5,0.6,0.72,0.85], up:[110,190,320], projectile:'dart' },
      { id:'t3', nm:'Enforcer', icon:'üëä', cost:120, clr:'#f97316', dmg:[45,70,105,160], rng:[2.5,2.9,3.3,3.8], rate:[0.55,0.65,0.78,0.92], up:[90,155,260], splash:[1.2,1.5,1.8,2.2], projectile:'hammer' },
      { id:'t4', nm:'Ice Spray', icon:'‚ùÑÔ∏è', cost:90, clr:'#38bdf8', dmg:[18,28,42,60], rng:[3.0,3.4,3.8,4.3], rate:[1.3,1.55,1.8,2.1], up:[65,115,190], slow:0.5, slowDur:[2,2.5,3.2,4], projectile:'shard' },
      { id:'t5', nm:'Goalie', icon:'ü•Ö', cost:200, clr:'#ffd700', dmg:[100,155,230,350], rng:[2.0,2.4,2.8,3.2], rate:[0.7,0.85,1.0,1.2], up:[140,250,420], projectile:'glove' },
      { id:'t6', nm:'Power Play', icon:'‚ö°', cost:160, clr:'#a855f7', dmg:[35,55,82,125], rng:[3.5,4.0,4.5,5.1], rate:[0.85,1.0,1.15,1.35], up:[120,200,340], chain:[2,3,4,6], chainRng:2.2, projectile:'lightning' },
      { id:'t7', nm:'Hot Stick', icon:'üî•', cost:140, clr:'#f97316', dmg:[15,24,36,52], rng:[2.6,3.0,3.4,3.9], rate:[3.5,4.2,5.0,6.0], up:[100,175,290], burn:[10,16,24,35], burnDur:3, projectile:'fireball' },
      { id:'t8', nm:'Captain', icon:'üëë', cost:280, clr:'#fbbf24', dmg:[200,320,480,720], rng:[5.5,6.1,6.8,7.5], rate:[0.2,0.26,0.33,0.42], up:[200,360,600], crit:0.4, projectile:'star' }
    ],
    enemies: [
      { id:'e1', nm:'Puck', hp:50, spd:2.4, rwd:10, sz:1.0 },
      { id:'e2', nm:'Hot Puck', hp:70, spd:2.0, rwd:15, fire:true, sz:1.0 },
      { id:'e3', nm:'Flying Puck', hp:45, spd:2.8, rwd:12, flying:true, sz:0.9 },
      { id:'e4', nm:'Heavy Puck', hp:250, spd:0.7, rwd:35, armor:0.4, sz:1.4 },
      { id:'e5', nm:'Inferno Puck', hp:400, spd:0.55, rwd:55, fire:true, armor:0.3, sz:1.5 },
      { id:'e6', nm:'Flying Fire', hp:120, spd:2.2, rwd:25, flying:true, fire:true, sz:1.0 },
      { id:'e7', nm:'Boss Puck', hp:2500, spd:0.35, rwd:350, armor:0.35, boss:true, sz:2.2 }
    ]
  },
  soccer: {
    name: 'Soccer Stadium', icon: '‚öΩ', color: '#22c55e',
    groundColor: 0x2d8a3a, pathColor: 0x215a28, envColor: 0x0a1a0a,
    maps: [
      { name: 'Backyard', cols: 18, rows: 11, waves: 15, money: 650, lives: 20, diff: 1 },
      { name: 'School Field', cols: 20, rows: 12, waves: 20, money: 700, lives: 18, diff: 2 },
      { name: 'Club Ground', cols: 22, rows: 13, waves: 25, money: 750, lives: 15, diff: 3 },
      { name: 'Premier League', cols: 24, rows: 14, waves: 30, money: 850, lives: 12, diff: 4 },
      { name: 'World Cup', cols: 26, rows: 15, waves: 40, money: 1000, lives: 10, diff: 5 },
      { name: 'Street Pitch', cols: 28, rows: 16, waves: 45, money: 1200, lives: 8, diff: 6 },
      { name: 'Beach Field', cols: 30, rows: 17, waves: 50, money: 1300, lives: 7, diff: 7 },
      { name: 'Champions League', cols: 32, rows: 18, waves: 55, money: 1400, lives: 6, diff: 8 },
      { name: 'Olympic Stadium', cols: 34, rows: 19, waves: 60, money: 1500, lives: 5, diff: 9 },
      { name: 'Legendary Final', cols: 36, rows: 20, waves: 65, money: 1600, lives: 4, diff: 10 }
    ],
    towers: [
      { id:'t1', nm:'Striker', icon:'‚öΩ', cost:80, clr:'#22c55e', dmg:[28,44,66,100], rng:[2.6,3.0,3.4,3.9], rate:[1.15,1.35,1.6,1.9], up:[60,100,170], projectile:'ball' },
      { id:'t2', nm:'Free Kick', icon:'üéØ', cost:150, clr:'#fbbf24', dmg:[75,118,175,265], rng:[4.8,5.3,5.9,6.5], rate:[0.48,0.58,0.7,0.84], up:[110,190,320], projectile:'curveBall' },
      { id:'t3', nm:'Header', icon:'ü§ï', cost:120, clr:'#3b82f6', dmg:[50,78,118,178], rng:[2.8,3.2,3.6,4.1], rate:[0.5,0.6,0.72,0.86], up:[90,155,260], splash:[1.3,1.6,2.0,2.4], projectile:'headButt' },
      { id:'t4', nm:'Tackle', icon:'ü¶∂', cost:90, clr:'#f97316', dmg:[20,32,48,70], rng:[2.8,3.2,3.6,4.1], rate:[1.25,1.48,1.72,2.0], up:[65,115,190], slow:0.5, slowDur:[1.8,2.4,3.0,3.8], projectile:'tackle' },
      { id:'t5', nm:'Keeper', icon:'üß§', cost:200, clr:'#a855f7', dmg:[110,170,255,385], rng:[1.8,2.2,2.6,3.0], rate:[0.75,0.9,1.05,1.25], up:[140,250,420], projectile:'glove' },
      { id:'t6', nm:'Playmaker', icon:'üîÑ', cost:160, clr:'#06b6d4', dmg:[38,60,90,135], rng:[3.8,4.3,4.9,5.5], rate:[0.82,0.96,1.12,1.3], up:[120,200,340], chain:[2,3,5,7], chainRng:2.5, projectile:'chain' },
      { id:'t7', nm:'Flare', icon:'üî•', cost:140, clr:'#ef4444', dmg:[16,26,40,58], rng:[2.4,2.8,3.2,3.7], rate:[3.2,3.9,4.7,5.6], up:[100,175,290], burn:[12,18,28,40], burnDur:3.5, projectile:'flare' },
      { id:'t8', nm:'Legend', icon:'üëë', cost:280, clr:'#fbbf24', dmg:[220,350,525,790], rng:[5.2,5.8,6.5,7.2], rate:[0.18,0.24,0.31,0.4], up:[200,360,600], crit:0.45, projectile:'legend' }
    ],
    enemies: [
      { id:'e1', nm:'Ball', hp:45, spd:2.5, rwd:10, sz:1.0 },
      { id:'e2', nm:'Fire Ball', hp:65, spd:2.1, rwd:15, fire:true, sz:1.0 },
      { id:'e3', nm:'Flying Ball', hp:40, spd:3.0, rwd:12, flying:true, sz:0.9 },
      { id:'e4', nm:'Heavy Ball', hp:280, spd:0.65, rwd:35, armor:0.45, sz:1.4 },
      { id:'e5', nm:'Inferno Ball', hp:450, spd:0.5, rwd:55, fire:true, armor:0.35, sz:1.5 },
      { id:'e6', nm:'Flying Fire', hp:130, spd:2.3, rwd:25, flying:true, fire:true, sz:1.0 },
      { id:'e7', nm:'Boss Ball', hp:2800, spd:0.32, rwd:400, armor:0.38, boss:true, sz:2.2 }
    ]
  }
};

const SAVE_KEY = 'hvsstd_save_v1';
const DEFAULT_SETTINGS = { gameSpeed: 1, sfx: true };

let saveData = null;
let currentMapIndex = 0;
let resizeObserver = null;
let listenersBound = false;
let boundCanvas = null;

let theme, themeData, mapData;
let COLS, ROWS, PATH=[], SPAWN, BASE, WAVES=[];
let money, lives, wave, score, gameSpeed=1;
let grid=[], towers=[], enemies=[], projectiles=[], particles=[];
let selectedTower=null, selectedPlaced=null, sellMode=false, waveActive=false;
let running=false, lastTime=0, animTime=0;
let scene, camera, renderer, raycaster, mouse, cells=[];
let camAngle=Math.PI/4, camHeight=14, camDist=22;
let dragging=false, dragMoved=false, lastX=0, lastY=0, touchStart=0;

// Save system helpers (localStorage persistence)
function createDefaultThemeProgress(themeKey) {
  return {
    unlockedMaps: 1,
    lastMap: 0,
    maps: THEMES[themeKey].maps.map(() => ({ bestScore: 0, bestStars: 0 }))
  };
}

function createDefaultSave() {
  return {
    version: 1,
    settings: { ...DEFAULT_SETTINGS },
    progress: {
      hockey: createDefaultThemeProgress('hockey'),
      soccer: createDefaultThemeProgress('soccer')
    },
    meta: {
      lastTheme: null,
      lastMap: 0
    }
  };
}

function mergeSave(base, incoming) {
  const merged = JSON.parse(JSON.stringify(base));
  if (!incoming || typeof incoming !== 'object') return merged;
  merged.settings = { ...merged.settings, ...(incoming.settings || {}) };
  merged.meta = { ...merged.meta, ...(incoming.meta || {}) };
  ['hockey', 'soccer'].forEach(key => {
    const savedTheme = incoming.progress && incoming.progress[key];
    if (!savedTheme) return;
    const maxMaps = THEMES[key].maps.length;
    merged.progress[key].unlockedMaps = Math.min(Math.max(1, savedTheme.unlockedMaps || 1), maxMaps);
    merged.progress[key].lastMap = Math.min(Math.max(0, savedTheme.lastMap || 0), maxMaps - 1);
    merged.progress[key].maps = merged.progress[key].maps.map((map, idx) => {
      const savedMap = savedTheme.maps && savedTheme.maps[idx];
      return {
        bestScore: Math.max(map.bestScore, savedMap ? savedMap.bestScore || 0 : 0),
        bestStars: Math.max(map.bestStars, savedMap ? savedMap.bestStars || 0 : 0)
      };
    });
  });
  return merged;
}

function loadSaveData() {
  const base = createDefaultSave();
  let parsed = null;
  try {
    const raw = localStorage.getItem(SAVE_KEY);
    if (raw) parsed = JSON.parse(raw);
  } catch (err) {
    parsed = null;
  }
  saveData = mergeSave(base, parsed);
  gameSpeed = saveData.settings.gameSpeed;
  updateSettingsUI();
}

function persistSave() {
  if (!saveData) return;
  try {
    localStorage.setItem(SAVE_KEY, JSON.stringify(saveData));
  } catch (err) {
    // Ignore storage failures (private mode, quota, etc.)
  }
}

function getThemeProgress(themeKey) {
  return saveData && saveData.progress ? saveData.progress[themeKey] : null;
}

function getMapProgress(themeKey, mapIndex) {
  const progress = getThemeProgress(themeKey);
  return progress && progress.maps ? progress.maps[mapIndex] : null;
}

function updateSettingsUI() {
  const sfxToggle = document.getElementById('sfxToggle');
  if (sfxToggle && saveData) {
    sfxToggle.textContent = `SFX: ${saveData.settings.sfx ? 'On' : 'Off'}`;
    sfxToggle.classList.toggle('active', saveData.settings.sfx);
  }
  updateSpeedButtons();
}

function updateSpeedButtons() {
  document.querySelectorAll('.speed-btn, .speed-setting').forEach(btn => {
    btn.classList.toggle('active', +btn.dataset.speed === gameSpeed);
  });
}

function setSfxEnabled(enabled) {
  if (!saveData) return;
  saveData.settings.sfx = enabled;
  updateSettingsUI();
  persistSave();
}

function recordGameResult(isWin) {
  if (!saveData) return;
  const progress = getThemeProgress(theme);
  if (!progress) return;
  const mapProgress = getMapProgress(theme, currentMapIndex);
  if (mapProgress) {
    mapProgress.bestScore = Math.max(mapProgress.bestScore, score);
    if (isWin) {
      const maxLives = mapData.lives;
      const stars = lives >= maxLives ? 5 : lives >= Math.ceil(maxLives * 0.7) ? 3 : 1;
      mapProgress.bestStars = Math.max(mapProgress.bestStars, stars);
    }
  }
  if (isWin) {
    const maxMaps = THEMES[theme].maps.length;
    progress.unlockedMaps = Math.min(Math.max(progress.unlockedMaps, currentMapIndex + 2), maxMaps);
  }
  persistSave();
}

// Resize helpers to keep the canvas in sync with layout changes
function resizeRendererToDisplaySize() {
  if (!renderer || !camera) return false;
  const canvas = renderer.domElement;
  const rect = canvas.getBoundingClientRect();
  const width = Math.max(1, Math.floor(rect.width));
  const height = Math.max(1, Math.floor(rect.height));
  const pixelRatio = Math.min(window.devicePixelRatio || 1, 2);
  renderer.setPixelRatio(pixelRatio);
  const needResize = canvas.width !== Math.floor(width * pixelRatio) || canvas.height !== Math.floor(height * pixelRatio);
  if (needResize) {
    renderer.setSize(width, height, false);
    camera.aspect = width / height;
    camera.updateProjectionMatrix();
  }
  return needResize;
}

function bindInputListeners(canvas) {
  if (listenersBound) return;
  canvas.addEventListener('touchstart', onTouchStart, { passive: false });
  canvas.addEventListener('touchmove', onTouchMove, { passive: false });
  canvas.addEventListener('touchend', onTouchEnd, { passive: false });
  canvas.addEventListener('mousedown', onMouseDown);
  canvas.addEventListener('mousemove', onMouseMove);
  canvas.addEventListener('mouseup', onMouseUp);
  canvas.addEventListener('wheel', onWheel, { passive: false });
  canvas.addEventListener('click', onClick);
  window.addEventListener('resize', onResize);
  listenersBound = true;
  boundCanvas = canvas;
}

function unbindInputListeners() {
  if (!listenersBound || !boundCanvas) return;
  boundCanvas.removeEventListener('touchstart', onTouchStart);
  boundCanvas.removeEventListener('touchmove', onTouchMove);
  boundCanvas.removeEventListener('touchend', onTouchEnd);
  boundCanvas.removeEventListener('mousedown', onMouseDown);
  boundCanvas.removeEventListener('mousemove', onMouseMove);
  boundCanvas.removeEventListener('mouseup', onMouseUp);
  boundCanvas.removeEventListener('wheel', onWheel);
  boundCanvas.removeEventListener('click', onClick);
  window.removeEventListener('resize', onResize);
  listenersBound = false;
  boundCanvas = null;
}

function setupResizeObserver() {
  const wrap = document.querySelector('.canvas-wrap');
  if (!wrap || !renderer) return;
  if (resizeObserver) resizeObserver.disconnect();
  resizeObserver = new ResizeObserver(() => resizeRendererToDisplaySize());
  resizeObserver.observe(wrap);
}

function showScreen(id) {
  document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
  document.getElementById(id).classList.add('active');
}

function selectTheme(t) {
  if (!saveData) loadSaveData();
  theme = t;
  themeData = THEMES[t];
  document.getElementById('mapTitle').textContent = themeData.icon + ' ' + themeData.name;
  document.getElementById('mapTitle').style.color = themeData.color;
  
  if (saveData) {
    saveData.meta.lastTheme = t;
    persistSave();
  }

  const progress = getThemeProgress(t);
  const unlocked = progress ? progress.unlockedMaps : 1;
  const lastPlayed = progress ? progress.lastMap : null;
  const grid = document.getElementById('mapGrid');
  grid.innerHTML = '';
  themeData.maps.forEach((m, i) => {
    const mapProgress = getMapProgress(t, i);
    const stars = mapProgress ? mapProgress.bestStars : 0;
    const bestScore = mapProgress ? mapProgress.bestScore : 0;
    const locked = i >= unlocked;
    const starsHtml = [1,2,3,4,5].map(n => `<span class="${n<=stars?'on':''}">‚≠ê</span>`).join('');
    const bestHtml = bestScore ? `<div class="map-best">Best ${bestScore}</div>` : '';
    const lockHtml = locked ? '<div class="map-lock">üîí Locked</div>' : '';
    const card = document.createElement('div');
    card.className = 'map-card';
    card.classList.toggle('locked', locked);
    card.classList.toggle('last-played', lastPlayed === i);
    card.style.setProperty('--c', themeData.color);
    card.innerHTML = `<div class="map-card-icon">${themeData.icon}</div><div class="map-card-name">${m.name}</div><div class="map-card-info">${m.waves} Waves ‚Ä¢ ${m.cols}√ó${m.rows}</div><div class="map-stars">${starsHtml}</div>${bestHtml}${lockHtml}`;
    if (!locked) {
      card.onclick = () => startGame(i);
    }
    grid.appendChild(card);
  });
  showScreen('mapScreen');
}

function startGame(idx) {
  if (!saveData) loadSaveData();
  currentMapIndex = idx;
  mapData = themeData.maps[idx];
  COLS = mapData.cols;
  ROWS = mapData.rows;
  money = mapData.money;
  lives = mapData.lives;
  wave = 0;
  score = 0;
  gameSpeed = saveData ? saveData.settings.gameSpeed : 1;
  grid = [];
  towers = [];
  enemies = [];
  projectiles = [];
  particles = [];
  selectedTower = null;
  selectedPlaced = null;
  sellMode = false;
  waveActive = false;
  
  generateMap();
  WAVES = generateWaves(mapData.waves);
  
  showScreen('gameScreen');
  if (saveData) {
    saveData.meta.lastTheme = theme;
    saveData.meta.lastMap = idx;
    if (saveData.progress && saveData.progress[theme]) {
      saveData.progress[theme].lastMap = idx;
    }
    persistSave();
  }
  updateSpeedButtons();
  requestAnimationFrame(() => {
    requestAnimationFrame(() => {
      init3D();
      resizeRendererToDisplaySize();
      renderTowers();
      updateHUD();
      running = true;
      lastTime = performance.now();
      gameLoop(lastTime);
    });
  });
}

function exitGame() {
  running = false;
  persistSave();
  unbindInputListeners();
  if (resizeObserver) resizeObserver.disconnect();
  selectTheme(theme);
}

function generateMap() {
  for (let y = 0; y < ROWS; y++) {
    grid[y] = [];
    for (let x = 0; x < COLS; x++) grid[y][x] = { type: 'ground', tower: null };
  }
  
  let py = Math.floor(ROWS * 0.3 + Math.random() * ROWS * 0.4);
  SPAWN = { x: 0, y: py };
  PATH = [];
  
  for (let px = 0; px < COLS; px++) {
    PATH.push([px, py]);
    if (px < COLS - 1) {
      const r = Math.random();
      if (r < 0.3 && py > 1) py--;
      else if (r < 0.6 && py < ROWS - 2) py++;
    }
  }
  
  PATH.forEach(([x, y]) => grid[y][x].type = 'path');
  grid[SPAWN.y][SPAWN.x].type = 'spawn';
  BASE = { x: PATH[PATH.length-1][0], y: PATH[PATH.length-1][1] };
  grid[BASE.y][BASE.x].type = 'base';
}

function generateWaves(num) {
  const waves = [];
  const e = themeData.enemies;
  for (let w = 1; w <= num; w++) {
    const wv = {};
    wv[e[0].id] = 5 + Math.floor(w * 1.3);
    if (w >= 2) wv[e[1].id] = Math.floor(w * 0.6);
    if (w >= 3) wv[e[2].id] = Math.floor(w * 0.7);
    if (w >= 5) wv[e[3].id] = Math.floor((w-3) * 0.4);
    if (w >= 8) wv[e[4].id] = Math.floor((w-6) * 0.25);
    if (w >= 10) wv[e[5].id] = Math.floor((w-8) * 0.35);
    if (w % 5 === 0) wv[e[6].id] = 1 + Math.floor(w / 12);
    waves.push(wv);
  }
  return waves;
}

function init3D() {
  const wrap = document.querySelector('.canvas-wrap');
  const canvas = document.getElementById('gameCanvas');
  if (renderer) renderer.dispose();
  
  const rect = wrap.getBoundingClientRect();
  const w = Math.max(1, rect.width);
  const h = Math.max(1, rect.height);
  scene = new THREE.Scene();
  scene.background = new THREE.Color(themeData.envColor);
  scene.fog = new THREE.Fog(themeData.envColor, 35, 70);
  
  camera = new THREE.PerspectiveCamera(50, w/h, 0.1, 200);
  camDist = Math.max(COLS, ROWS) * 0.9;
  camHeight = camDist * 0.6;
  updateCamera();
  
  renderer = new THREE.WebGLRenderer({ canvas, antialias: true, powerPreference: 'high-performance' });
  renderer.outputEncoding = THREE.sRGBEncoding;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = theme === 'hockey' ? 1.05 : 1.1;
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  
  resizeRendererToDisplaySize();

  const ambientIntensity = theme === 'hockey' ? 0.5 : 0.65;
  const ambientColor = theme === 'hockey' ? 0xcfe7ff : 0xdff8e0;
  scene.add(new THREE.AmbientLight(ambientColor, ambientIntensity));
  const hemi = new THREE.HemisphereLight(0xffffff, themeData.groundColor, theme === 'hockey' ? 0.3 : 0.35);
  scene.add(hemi);

  const sunColor = theme === 'hockey' ? 0xf2f8ff : 0xfff3d6;
  const sun = new THREE.DirectionalLight(sunColor, theme === 'hockey' ? 1.15 : 1.05);
  sun.position.set(COLS*0.4, 25, ROWS*0.4);
  sun.castShadow = true;
  const shadowSize = window.matchMedia('(max-width: 768px)').matches ? 1024 : 2048;
  sun.shadow.mapSize.width = shadowSize;
  sun.shadow.mapSize.height = shadowSize;
  sun.shadow.camera.near = 1;
  sun.shadow.camera.far = 60;
  sun.shadow.camera.left = -COLS;
  sun.shadow.camera.right = COLS;
  sun.shadow.camera.top = ROWS;
  sun.shadow.camera.bottom = -ROWS;
  scene.add(sun);
  
  // Add rim light for better depth
  const rimLight = new THREE.DirectionalLight(0x4488ff, 0.3);
  rimLight.position.set(-COLS*0.5, 15, -ROWS*0.5);
  scene.add(rimLight);
  
  raycaster = new THREE.Raycaster();
  mouse = new THREE.Vector2();
  
  if (theme === 'hockey') buildHockeyRink();
  else buildSoccerPitch();

  bindInputListeners(canvas);
  setupResizeObserver();
}

function buildHockeyRink() {
  cells = [];
  const hw = COLS/2, hh = ROWS/2;
  
  const ice = new THREE.Mesh(new THREE.PlaneGeometry(COLS+2, ROWS+2), new THREE.MeshLambertMaterial({ color: themeData.groundColor }));
  ice.rotation.x = -Math.PI/2;
  ice.receiveShadow = true;
  scene.add(ice);
  
  const boardMat = new THREE.MeshLambertMaterial({ color: 0xffffff });
  [[0, -hh-0.7, COLS+1.5, 0.5, 0.3], [0, hh+0.7, COLS+1.5, 0.5, 0.3], [-hw-0.7, 0, 0.3, 0.5, ROWS+1.5], [hw+0.7, 0, 0.3, 0.5, ROWS+1.5]].forEach(([x,z,w,h,d]) => {
    const board = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), boardMat);
    board.position.set(x, h/2, z);
    board.castShadow = true;
    scene.add(board);
  });
  
  const lineOffset = { polygonOffset: true, polygonOffsetFactor: -1, polygonOffsetUnits: -1 };
  const redMat = new THREE.MeshBasicMaterial({ color: 0xcc0000, ...lineOffset });
  const blueMat = new THREE.MeshBasicMaterial({ color: 0x0055cc, ...lineOffset });
  
  const centerLine = new THREE.Mesh(new THREE.PlaneGeometry(0.18, ROWS), redMat);
  centerLine.rotation.x = -Math.PI/2;
  centerLine.position.y = 0.01;
  scene.add(centerLine);
  
  [-hw*0.38, hw*0.38].forEach(x => {
    const blueLine = new THREE.Mesh(new THREE.PlaneGeometry(0.15, ROWS), blueMat);
    blueLine.rotation.x = -Math.PI/2;
    blueLine.position.set(x, 0.01, 0);
    scene.add(blueLine);
  });
  
  const circle = new THREE.Mesh(new THREE.RingGeometry(2.0, 2.15, 48), blueMat);
  circle.rotation.x = -Math.PI/2;
  circle.position.y = 0.01;
  scene.add(circle);
  
  createHockeyGoal(-hw-0.2);
  createHockeyGoal(hw+0.2, true);
  
  buildPath(hw, hh);
  buildCells(hw, hh);
  buildLights(hw, hh);

  // Surround the rink with stands and cheering fans
  buildStands(hw, hh);
}

function createHockeyGoal(x, flip=false) {
  const mat = new THREE.MeshLambertMaterial({ color: 0xcc0000 });
  const netMat = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true, transparent: true, opacity: 0.4 });
  const postH = 1.1, postW = 1.3;
  
  const postGeo = new THREE.CylinderGeometry(0.04, 0.04, postH, 8);
  [-postW/2, postW/2].forEach(z => {
    const post = new THREE.Mesh(postGeo, mat);
    post.position.set(x, postH/2, z);
    scene.add(post);
  });
  const crossbar = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, postW, 8), mat);
  crossbar.rotation.x = Math.PI/2;
  crossbar.position.set(x, postH, 0);
  scene.add(crossbar);
  
  const net = new THREE.Mesh(new THREE.BoxGeometry(0.7, postH, postW), netMat);
  net.position.set(x + (flip ? 0.35 : -0.35), postH/2, 0);
  scene.add(net);
}

function buildSoccerPitch() {
  cells = [];
  const hw = COLS/2, hh = ROWS/2;
  
  for (let i = 0; i < COLS; i++) {
    const stripe = new THREE.Mesh(new THREE.PlaneGeometry(1.01, ROWS+2), new THREE.MeshLambertMaterial({ color: i%2===0 ? 0x3da84a : 0x2d8a3a }));
    stripe.rotation.x = -Math.PI/2;
    stripe.position.set(i - hw + 0.5, 0.005, 0);
    stripe.receiveShadow = true;
    scene.add(stripe);
  }
  
  const lineMat = new THREE.MeshBasicMaterial({ color: 0xffffff, polygonOffset: true, polygonOffsetFactor: -1, polygonOffsetUnits: -1 });
  [[0, -hh, COLS, 0.1], [0, hh, COLS, 0.1]].forEach(([x,z,w,d]) => {
    const line = new THREE.Mesh(new THREE.PlaneGeometry(w, d), lineMat);
    line.rotation.x = -Math.PI/2;
    line.position.set(x, 0.01, z);
    scene.add(line);
  });
  
  const halfLine = new THREE.Mesh(new THREE.PlaneGeometry(0.1, ROWS), lineMat);
  halfLine.rotation.x = -Math.PI/2;
  halfLine.position.y = 0.01;
  scene.add(halfLine);
  
  const circle = new THREE.Mesh(new THREE.RingGeometry(2.3, 2.45, 48), lineMat);
  circle.rotation.x = -Math.PI/2;
  circle.position.y = 0.01;
  scene.add(circle);
  
  createSoccerGoal(-hw-0.2);
  createSoccerGoal(hw+0.2, true);
  
  buildPath(hw, hh);
  buildCells(hw, hh);
  buildLights(hw, hh);

  // Surround the pitch with stands and cheering fans
  buildStands(hw, hh);
}

function createSoccerGoal(x, flip=false) {
  const mat = new THREE.MeshLambertMaterial({ color: 0xffffff });
  const netMat = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true, transparent: true, opacity: 0.4 });
  const postH = 1.4, postW = 2.2;
  
  const postGeo = new THREE.CylinderGeometry(0.05, 0.05, postH, 8);
  [-postW/2, postW/2].forEach(z => {
    const post = new THREE.Mesh(postGeo, mat);
    post.position.set(x, postH/2, z);
    scene.add(post);
  });
  const crossbar = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, postW, 8), mat);
  crossbar.rotation.x = Math.PI/2;
  crossbar.position.set(x, postH, 0);
  scene.add(crossbar);
  
  const net = new THREE.Mesh(new THREE.BoxGeometry(0.8, postH, postW), netMat);
  net.position.set(x + (flip ? 0.4 : -0.4), postH/2, 0);
  scene.add(net);
}

function buildPath(hw, hh) {
  // Path material: semi‚Äëtransparent to allow subtle blending with the ground
  const pathMat = new THREE.MeshLambertMaterial({ color: themeData.pathColor, transparent: true, opacity: 0.5 });
  
  PATH.forEach(([px, py]) => {
    const tile = new THREE.Mesh(new THREE.BoxGeometry(0.96, 0.06, 0.96), pathMat);
    tile.position.set(px - hw + 0.5, 0.035, py - hh + 0.5);
    tile.receiveShadow = true;
    scene.add(tile);
  });
  
  // Spawn portal - more detailed
  const spawnGroup = new THREE.Group();
  const spawnRing = new THREE.Mesh(new THREE.TorusGeometry(0.5, 0.08, 12, 32), new THREE.MeshBasicMaterial({ color: 0x9b59b6 }));
  spawnRing.rotation.x = Math.PI/2;
  spawnGroup.add(spawnRing);
  const spawnInner = new THREE.Mesh(new THREE.CircleGeometry(0.4, 32), new THREE.MeshBasicMaterial({ color: 0x9b59b6, transparent: true, opacity: 0.3 }));
  spawnInner.rotation.x = -Math.PI/2;
  spawnGroup.add(spawnInner);
  spawnGroup.position.set(SPAWN.x - hw + 0.5, 0.1, SPAWN.y - hh + 0.5);
  scene.add(spawnGroup);
  
  // Base marker - more detailed
  const baseGroup = new THREE.Group();
  const baseRing = new THREE.Mesh(new THREE.TorusGeometry(0.5, 0.08, 12, 32), new THREE.MeshBasicMaterial({ color: 0xfbbf24 }));
  baseRing.rotation.x = Math.PI/2;
  baseGroup.add(baseRing);
  const baseInner = new THREE.Mesh(new THREE.CircleGeometry(0.4, 32), new THREE.MeshBasicMaterial({ color: 0xfbbf24, transparent: true, opacity: 0.3 }));
  baseInner.rotation.x = -Math.PI/2;
  baseGroup.add(baseInner);
  baseGroup.position.set(BASE.x - hw + 0.5, 0.1, BASE.y - hh + 0.5);
  scene.add(baseGroup);
}

function buildCells(hw, hh) {
  for (let y = 0; y < ROWS; y++) {
    for (let x = 0; x < COLS; x++) {
      const cell = new THREE.Mesh(new THREE.PlaneGeometry(1, 1), new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 }));
      cell.rotation.x = -Math.PI/2;
      cell.position.set(x - hw + 0.5, 0.22, y - hh + 0.5);
      cell.userData = { x, y, isCell: true };
      scene.add(cell);
      cells.push(cell);
    }
  }
}

function buildLights(hw, hh) {
  [[-hw-3, -hh-3], [-hw-3, hh+3], [hw+3, -hh-3], [hw+3, hh+3]].forEach(([x, z]) => {
    const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.2, 8, 8), new THREE.MeshLambertMaterial({ color: 0x333333 }));
    pole.position.set(x, 4, z);
    scene.add(pole);
    const light = new THREE.Mesh(new THREE.BoxGeometry(1.4, 0.25, 1.4), new THREE.MeshBasicMaterial({ color: 0xffffdd }));
    light.position.set(x, 8.15, z);
    scene.add(light);
  });
}

// Build surrounding stands with instanced fans. Stands are simple boxes around the perimeter
// and fans are colored spheres randomly placed on top of the stands. This adds visual
// interest and makes the arena feel alive. The number and size of stands scale with
// COLS and ROWS. Fans are randomly colored from a small palette.
function buildStands(hw, hh) {
  const standMat = new THREE.MeshLambertMaterial({ color: 0x444444 });
  const standHeight = 1.0;
  const standDepth = 2.0;
  const fanGeo = new THREE.SphereGeometry(0.1, 8, 8);
  const fanMat = new THREE.MeshLambertMaterial({ vertexColors: true });
  const fanColors = [0xff5555, 0xffff55, 0x55ff55, 0x5555ff, 0xff55ff, 0x55ffff];
  const fanDummy = new THREE.Object3D();
  // top and bottom stands
  const topBottomDepth = standDepth;
  const standWidth = COLS + 4;
  const zPositions = [-(hh + 1.5 + topBottomDepth / 2), hh + 1.5 + topBottomDepth / 2];
  zPositions.forEach(z => {
    const stand = new THREE.Mesh(new THREE.BoxGeometry(standWidth, standHeight, topBottomDepth), standMat);
    stand.position.set(0, standHeight / 2, z);
    stand.receiveShadow = true;
    stand.castShadow = true;
    scene.add(stand);
    const fanCount = Math.max(20, Math.floor(COLS * 2));
    const fans = new THREE.InstancedMesh(fanGeo, fanMat, fanCount);
    for (let i = 0; i < fanCount; i++) {
      const offsetX = (i / fanCount - 0.5) * (standWidth * 0.9);
      const offsetZ = z + (Math.random() * topBottomDepth - topBottomDepth / 2);
      fanDummy.position.set(offsetX, standHeight + 0.05 + Math.random() * 0.1, offsetZ);
      fanDummy.updateMatrix();
      fans.setMatrixAt(i, fanDummy.matrix);
      fans.setColorAt(i, new THREE.Color(fanColors[Math.floor(Math.random() * fanColors.length)]));
    }
    fans.castShadow = false;
    fans.receiveShadow = false;
    fans.instanceMatrix.needsUpdate = true;
    if (fans.instanceColor) fans.instanceColor.needsUpdate = true;
    scene.add(fans);
  });
  // left and right stands
  const sideWidth = ROWS + 4;
  const xPositions = [-(hw + 1.5 + standDepth / 2), hw + 1.5 + standDepth / 2];
  xPositions.forEach(x => {
    const stand = new THREE.Mesh(new THREE.BoxGeometry(standDepth, standHeight, sideWidth), standMat);
    stand.position.set(x, standHeight / 2, 0);
    stand.receiveShadow = true;
    stand.castShadow = true;
    scene.add(stand);
    const fanCount = Math.max(20, Math.floor(ROWS * 2));
    const fans = new THREE.InstancedMesh(fanGeo, fanMat, fanCount);
    for (let i = 0; i < fanCount; i++) {
      const offsetZ = (i / fanCount - 0.5) * (sideWidth * 0.9);
      const offsetX = x + (Math.random() * standDepth - standDepth / 2);
      fanDummy.position.set(offsetX, standHeight + 0.05 + Math.random() * 0.1, offsetZ);
      fanDummy.updateMatrix();
      fans.setMatrixAt(i, fanDummy.matrix);
      fans.setColorAt(i, new THREE.Color(fanColors[Math.floor(Math.random() * fanColors.length)]));
    }
    fans.castShadow = false;
    fans.receiveShadow = false;
    fans.instanceMatrix.needsUpdate = true;
    if (fans.instanceColor) fans.instanceColor.needsUpdate = true;
    scene.add(fans);
  });
}

// ========================================
// ENHANCED TOWER CREATION - MUCH BETTER!
// ========================================
function createTowerMesh(tower) {
  const td = themeData.towers.find(t => t.id === tower.type);
  const color = new THREE.Color(td.clr);
  const group = new THREE.Group();
  const hw = COLS/2, hh = ROWS/2;
  const lv = tower.lv || 0;
  const scale = 1 + lv * 0.08; // Towers grow slightly with level
  
  // Materials
  const baseMat = new THREE.MeshStandardMaterial({ color: 0x1a1a2e, metalness: 0.3, roughness: 0.7 });
  const bodyMat = new THREE.MeshStandardMaterial({ color, metalness: 0.4, roughness: 0.5 });
  const glowMat = new THREE.MeshBasicMaterial({ color });
  const metalMat = new THREE.MeshStandardMaterial({ color: 0x888899, metalness: 0.8, roughness: 0.2 });
  const darkMat = new THREE.MeshStandardMaterial({ color: 0x222233, metalness: 0.5, roughness: 0.5 });
  const whiteMat = new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 0.1, roughness: 0.8 });
  const goldMat = new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.9, roughness: 0.1 });
  
  // === HEXAGONAL BASE PLATFORM ===
  const baseShape = new THREE.CylinderGeometry(0.4 * scale, 0.45 * scale, 0.12, 6);
  const base = new THREE.Mesh(baseShape, baseMat);
  base.position.y = 0.06;
  base.castShadow = true;
  base.receiveShadow = true;
  group.add(base);
  
  // Base rim glow
  const baseRim = new THREE.Mesh(new THREE.TorusGeometry(0.42 * scale, 0.025, 8, 6), glowMat);
  baseRim.rotation.x = Math.PI/2;
  baseRim.position.y = 0.12;
  group.add(baseRim);
  
  // Level indicator stars
  for (let i = 0; i <= lv; i++) {
    const star = new THREE.Mesh(new THREE.OctahedronGeometry(0.04, 0), goldMat);
    const angle = (i / 4) * Math.PI * 2 - Math.PI/2;
    star.position.set(Math.cos(angle) * 0.35 * scale, 0.14, Math.sin(angle) * 0.35 * scale);
    star.rotation.y = Math.PI/4;
    group.add(star);
  }
  
  // Build tower based on type
  const towerIdx = parseInt(tower.type.substring(1)) - 1;
  
  if (theme === 'hockey') {
    buildHockeyTowerMesh(group, towerIdx, scale, bodyMat, glowMat, metalMat, darkMat, whiteMat, goldMat, color);
  } else {
    buildSoccerTowerMesh(group, towerIdx, scale, bodyMat, glowMat, metalMat, darkMat, whiteMat, goldMat, color);
  }
  
  // Range indicator
  const range = new THREE.Mesh(
    new THREE.RingGeometry(tower.rng - 0.05, tower.rng, 64),
    new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.15, side: THREE.DoubleSide })
  );
  range.rotation.x = -Math.PI/2;
  range.position.y = 0.02;
  group.add(range);
  tower.rangeMesh = range;
  
  group.position.set(tower.x - hw + 0.5, 0.08, tower.y - hh + 0.5);
  scene.add(group);
  tower.animParts = group.userData.animParts || [];
  return group;
}

function buildHockeyTowerMesh(group, idx, scale, bodyMat, glowMat, metalMat, darkMat, whiteMat, goldMat, color) {
  group.userData.animParts = [];
  
  switch(idx) {
    case 0: // Slap Shot - Hockey Player with Stick
      // Body/Jersey
      const jersey = new THREE.Mesh(new THREE.CylinderGeometry(0.15*scale, 0.18*scale, 0.35*scale, 8), bodyMat);
      jersey.position.y = 0.3*scale;
      jersey.castShadow = true;
      group.add(jersey);
      
      // Head with helmet
      const head = new THREE.Mesh(new THREE.SphereGeometry(0.1*scale, 12, 12), whiteMat);
      head.position.y = 0.55*scale;
      group.add(head);
      const helmet = new THREE.Mesh(new THREE.SphereGeometry(0.11*scale, 12, 8, 0, Math.PI*2, 0, Math.PI*0.6), bodyMat);
      helmet.position.y = 0.57*scale;
      group.add(helmet);
      
      // Hockey stick
      const stickShaft = new THREE.Mesh(new THREE.CylinderGeometry(0.02*scale, 0.02*scale, 0.6*scale, 6), darkMat);
      stickShaft.position.set(0.2*scale, 0.35*scale, 0);
      stickShaft.rotation.z = 0.4;
      group.add(stickShaft);
      
      const stickBlade = new THREE.Mesh(new THREE.BoxGeometry(0.2*scale, 0.04*scale, 0.06*scale), darkMat);
      stickBlade.position.set(0.35*scale, 0.12*scale, 0);
      group.add(stickBlade);
      
      // Glowing puck on stick
      const puck = new THREE.Mesh(new THREE.CylinderGeometry(0.06*scale, 0.06*scale, 0.02*scale, 16), glowMat);
      puck.position.set(0.35*scale, 0.16*scale, 0);
      puck.rotation.x = Math.PI/2;
      group.add(puck);
      group.userData.animParts.push({ mesh: puck, type: 'pulse' });
      break;
      
    case 1: // Sniper - Precision Rifle Tower
      // Tripod base
      for (let i = 0; i < 3; i++) {
        const leg = new THREE.Mesh(new THREE.CylinderGeometry(0.02*scale, 0.03*scale, 0.3*scale, 6), metalMat);
        const angle = (i / 3) * Math.PI * 2;
        leg.position.set(Math.cos(angle) * 0.12*scale, 0.18*scale, Math.sin(angle) * 0.12*scale);
        leg.rotation.x = Math.cos(angle) * 0.4;
        leg.rotation.z = Math.sin(angle) * 0.4;
        group.add(leg);
      }
      
      // Main body
      const rifleBody = new THREE.Mesh(new THREE.BoxGeometry(0.15*scale, 0.12*scale, 0.35*scale), bodyMat);
      rifleBody.position.y = 0.4*scale;
      rifleBody.castShadow = true;
      group.add(rifleBody);
      
      // Long barrel
      const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.025*scale, 0.03*scale, 0.5*scale, 8), metalMat);
      barrel.position.set(0, 0.4*scale, 0.4*scale);
      barrel.rotation.x = Math.PI/2;
      group.add(barrel);
      
      // Scope
      const scope = new THREE.Mesh(new THREE.CylinderGeometry(0.035*scale, 0.035*scale, 0.15*scale, 8), darkMat);
      scope.position.set(0, 0.52*scale, 0.1*scale);
      scope.rotation.x = Math.PI/2;
      group.add(scope);
      
      // Scope lens (glowing)
      const lens = new THREE.Mesh(new THREE.CircleGeometry(0.03*scale, 12), new THREE.MeshBasicMaterial({ color: 0xff0000 }));
      lens.position.set(0, 0.52*scale, 0.18*scale);
      group.add(lens);
      
      // Laser beam
      const laser = new THREE.Mesh(new THREE.CylinderGeometry(0.005*scale, 0.005*scale, 0.8*scale, 4), new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.6 }));
      laser.position.set(0, 0.52*scale, 0.55*scale);
      laser.rotation.x = Math.PI/2;
      group.add(laser);
      group.userData.animParts.push({ mesh: laser, type: 'blink' });
      break;
      
    case 2: // Enforcer - Boxing/Punching Tower
      // Muscular body
      const enfBody = new THREE.Mesh(new THREE.CylinderGeometry(0.2*scale, 0.25*scale, 0.4*scale, 8), bodyMat);
      enfBody.position.y = 0.32*scale;
      enfBody.castShadow = true;
      group.add(enfBody);
      
      // Shoulders
      const shoulders = new THREE.Mesh(new THREE.BoxGeometry(0.5*scale, 0.12*scale, 0.2*scale), bodyMat);
      shoulders.position.y = 0.52*scale;
      group.add(shoulders);
      
      // Head
      const enfHead = new THREE.Mesh(new THREE.SphereGeometry(0.1*scale, 10, 10), whiteMat);
      enfHead.position.y = 0.68*scale;
      group.add(enfHead);
      
      // Boxing gloves
      const gloveL = new THREE.Mesh(new THREE.SphereGeometry(0.1*scale, 10, 10), new THREE.MeshStandardMaterial({ color: 0xff0000, metalness: 0.2, roughness: 0.8 }));
      gloveL.position.set(-0.35*scale, 0.5*scale, 0.1*scale);
      gloveL.castShadow = true;
      group.add(gloveL);
      group.userData.animParts.push({ mesh: gloveL, type: 'punch', side: -1 });
      
      const gloveR = new THREE.Mesh(new THREE.SphereGeometry(0.1*scale, 10, 10), new THREE.MeshStandardMaterial({ color: 0xff0000, metalness: 0.2, roughness: 0.8 }));
      gloveR.position.set(0.35*scale, 0.5*scale, 0.1*scale);
      gloveR.castShadow = true;
      group.add(gloveR);
      group.userData.animParts.push({ mesh: gloveR, type: 'punch', side: 1 });
      
      // Impact rings
      for (let i = 0; i < 3; i++) {
        const ring = new THREE.Mesh(new THREE.TorusGeometry((0.15 + i*0.08)*scale, 0.015*scale, 6, 20), glowMat);
        ring.position.set(0.4*scale, 0.5*scale, 0.2*scale);
        ring.rotation.y = Math.PI/2;
        ring.material = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.3 - i*0.1 });
        group.add(ring);
      }
      break;
      
    case 3: // Ice Spray - Zamboni/Ice Machine
      // Machine body
      const zambBody = new THREE.Mesh(new THREE.BoxGeometry(0.4*scale, 0.25*scale, 0.5*scale), bodyMat);
      zambBody.position.y = 0.25*scale;
      zambBody.castShadow = true;
      group.add(zambBody);
      
      // Cab
      const cab = new THREE.Mesh(new THREE.BoxGeometry(0.25*scale, 0.18*scale, 0.2*scale), whiteMat);
      cab.position.set(0, 0.42*scale, -0.1*scale);
      group.add(cab);
      
      // Windows
      const window1 = new THREE.Mesh(new THREE.PlaneGeometry(0.08*scale, 0.08*scale), new THREE.MeshBasicMaterial({ color: 0x88ccff }));
      window1.position.set(0.126*scale, 0.44*scale, -0.1*scale);
      window1.rotation.y = Math.PI/2;
      group.add(window1);
      
      // Ice tank
      const tank = new THREE.Mesh(new THREE.CylinderGeometry(0.1*scale, 0.1*scale, 0.35*scale, 12), glowMat);
      tank.position.set(0, 0.3*scale, 0.15*scale);
      tank.rotation.x = Math.PI/2;
      group.add(tank);
      
      // Spray nozzles
      for (let i = 0; i < 5; i++) {
        const nozzle = new THREE.Mesh(new THREE.ConeGeometry(0.03*scale, 0.1*scale, 6), glowMat);
        nozzle.position.set((i-2)*0.08*scale, 0.18*scale, 0.35*scale);
        nozzle.rotation.x = -Math.PI/2;
        group.add(nozzle);
      }
      
      // Ice crystals floating
      for (let i = 0; i < 8; i++) {
        const crystal = new THREE.Mesh(new THREE.OctahedronGeometry(0.025*scale, 0), glowMat);
        crystal.position.set((Math.random()-0.5)*0.3*scale, 0.35*scale + Math.random()*0.2*scale, 0.4*scale + Math.random()*0.15*scale);
        group.add(crystal);
        group.userData.animParts.push({ mesh: crystal, type: 'float', offset: i });
      }
      break;
      
    case 4: // Goalie - Full Goalie
      // Leg pads
      const padL = new THREE.Mesh(new THREE.BoxGeometry(0.12*scale, 0.4*scale, 0.15*scale), whiteMat);
      padL.position.set(-0.1*scale, 0.3*scale, 0.08*scale);
      padL.castShadow = true;
      group.add(padL);
      
      const padR = new THREE.Mesh(new THREE.BoxGeometry(0.12*scale, 0.4*scale, 0.15*scale), whiteMat);
      padR.position.set(0.1*scale, 0.3*scale, 0.08*scale);
      padR.castShadow = true;
      group.add(padR);
      
      // Body
      const goalieBody = new THREE.Mesh(new THREE.BoxGeometry(0.35*scale, 0.3*scale, 0.2*scale), bodyMat);
      goalieBody.position.y = 0.55*scale;
      goalieBody.castShadow = true;
      group.add(goalieBody);
      
      // Blocker
      const blocker = new THREE.Mesh(new THREE.BoxGeometry(0.18*scale, 0.22*scale, 0.04*scale), whiteMat);
      blocker.position.set(-0.28*scale, 0.5*scale, 0.12*scale);
      group.add(blocker);
      
      // Glove
      const glove = new THREE.Mesh(new THREE.SphereGeometry(0.1*scale, 10, 10), bodyMat);
      glove.position.set(0.28*scale, 0.55*scale, 0.12*scale);
      glove.scale.set(1, 1, 0.6);
      group.add(glove);
      
      // Mask
      const mask = new THREE.Mesh(new THREE.SphereGeometry(0.11*scale, 12, 12), whiteMat);
      mask.position.y = 0.78*scale;
      group.add(mask);
      
      // Cage
      for (let i = 0; i < 5; i++) {
        const bar = new THREE.Mesh(new THREE.CylinderGeometry(0.008*scale, 0.008*scale, 0.13*scale, 4), metalMat);
        bar.position.set((i-2)*0.025*scale, 0.76*scale, 0.1*scale);
        bar.rotation.x = Math.PI/2;
        group.add(bar);
      }
      break;
      
    case 5: // Power Play - Tesla Coil
      // Coil base
      const coilBase = new THREE.Mesh(new THREE.CylinderGeometry(0.2*scale, 0.25*scale, 0.2*scale, 12), metalMat);
      coilBase.position.y = 0.2*scale;
      coilBase.castShadow = true;
      group.add(coilBase);
      
      // Main coil tower
      const coilTower = new THREE.Mesh(new THREE.CylinderGeometry(0.08*scale, 0.15*scale, 0.5*scale, 12), bodyMat);
      coilTower.position.y = 0.5*scale;
      group.add(coilTower);
      
      // Coil rings
      for (let i = 0; i < 6; i++) {
        const ring = new THREE.Mesh(new THREE.TorusGeometry((0.12 - i*0.01)*scale, 0.015*scale, 8, 24), glowMat);
        ring.position.y = (0.3 + i*0.08)*scale;
        ring.rotation.x = Math.PI/2;
        group.add(ring);
        group.userData.animParts.push({ mesh: ring, type: 'spin', speed: 1 + i*0.5 });
      }
      
      // Top electrode
      const electrode = new THREE.Mesh(new THREE.SphereGeometry(0.1*scale, 16, 16), glowMat);
      electrode.position.y = 0.85*scale;
      group.add(electrode);
      group.userData.animParts.push({ mesh: electrode, type: 'pulse' });
      
      // Lightning rods
      for (let i = 0; i < 4; i++) {
        const rod = new THREE.Mesh(new THREE.CylinderGeometry(0.015*scale, 0.015*scale, 0.2*scale, 4), metalMat);
        const angle = (i / 4) * Math.PI * 2;
        rod.position.set(Math.cos(angle)*0.18*scale, 0.35*scale, Math.sin(angle)*0.18*scale);
        group.add(rod);
        
        const tip = new THREE.Mesh(new THREE.SphereGeometry(0.025*scale, 8, 8), glowMat);
        tip.position.set(Math.cos(angle)*0.18*scale, 0.46*scale, Math.sin(angle)*0.18*scale);
        group.add(tip);
      }
      break;
      
    case 6: // Hot Stick - Flamethrower
      // Furnace base
      const furnace = new THREE.Mesh(new THREE.CylinderGeometry(0.18*scale, 0.22*scale, 0.3*scale, 10), darkMat);
      furnace.position.y = 0.25*scale;
      furnace.castShadow = true;
      group.add(furnace);
      
      // Grill vents
      for (let i = 0; i < 4; i++) {
        const vent = new THREE.Mesh(new THREE.BoxGeometry(0.12*scale, 0.02*scale, 0.04*scale), new THREE.MeshBasicMaterial({ color: 0xff4400 }));
        vent.position.set(0, 0.2*scale + i*0.06*scale, 0.2*scale);
        group.add(vent);
      }
      
      // Flame nozzle
      const nozzle = new THREE.Mesh(new THREE.CylinderGeometry(0.06*scale, 0.1*scale, 0.15*scale, 8), metalMat);
      nozzle.position.y = 0.48*scale;
      group.add(nozzle);
      
      // Flames
      const flameMat1 = new THREE.MeshBasicMaterial({ color: 0xff2200, transparent: true, opacity: 0.9 });
      const flameMat2 = new THREE.MeshBasicMaterial({ color: 0xff6600, transparent: true, opacity: 0.8 });
      const flameMat3 = new THREE.MeshBasicMaterial({ color: 0xffaa00, transparent: true, opacity: 0.7 });
      
      for (let i = 0; i < 5; i++) {
        const flame1 = new THREE.Mesh(new THREE.ConeGeometry(0.06*scale, 0.25*scale, 8), flameMat1);
        const angle = (i / 5) * Math.PI * 2;
        flame1.position.set(Math.cos(angle)*0.04*scale, 0.7*scale, Math.sin(angle)*0.04*scale);
        group.add(flame1);
        group.userData.animParts.push({ mesh: flame1, type: 'flame', offset: i });
      }
      
      const bigFlame = new THREE.Mesh(new THREE.ConeGeometry(0.08*scale, 0.35*scale, 8), flameMat3);
      bigFlame.position.y = 0.75*scale;
      group.add(bigFlame);
      group.userData.animParts.push({ mesh: bigFlame, type: 'flame', offset: 0 });
      break;
      
    case 7: // Captain - Trophy/Crown Tower
      // Pedestal
      const pedestal = new THREE.Mesh(new THREE.BoxGeometry(0.35*scale, 0.15*scale, 0.35*scale), darkMat);
      pedestal.position.y = 0.19*scale;
      pedestal.castShadow = true;
      group.add(pedestal);
      
      // Trophy stem
      const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.06*scale, 0.1*scale, 0.25*scale, 8), goldMat);
      stem.position.y = 0.4*scale;
      group.add(stem);
      
      // Trophy cup
      const cup = new THREE.Mesh(new THREE.CylinderGeometry(0.18*scale, 0.1*scale, 0.25*scale, 12), goldMat);
      cup.position.y = 0.65*scale;
      cup.castShadow = true;
      group.add(cup);
      
      // Handles
      for (let i = 0; i < 2; i++) {
        const handle = new THREE.Mesh(new THREE.TorusGeometry(0.06*scale, 0.015*scale, 6, 12, Math.PI), goldMat);
        handle.position.set((i === 0 ? -0.22 : 0.22)*scale, 0.65*scale, 0);
        handle.rotation.y = (i === 0 ? -Math.PI/2 : Math.PI/2);
        group.add(handle);
      }
      
      // Crown on top
      const crownBase = new THREE.Mesh(new THREE.CylinderGeometry(0.12*scale, 0.1*scale, 0.06*scale, 8), goldMat);
      crownBase.position.y = 0.82*scale;
      group.add(crownBase);
      
      for (let i = 0; i < 5; i++) {
        const spike = new THREE.Mesh(new THREE.ConeGeometry(0.025*scale, 0.1*scale, 4), goldMat);
        const angle = (i / 5) * Math.PI * 2;
        spike.position.set(Math.cos(angle)*0.08*scale, 0.9*scale, Math.sin(angle)*0.08*scale);
        group.add(spike);
      }
      
      // Center gem
      const gem = new THREE.Mesh(new THREE.OctahedronGeometry(0.04*scale, 0), new THREE.MeshBasicMaterial({ color: 0xff0000 }));
      gem.position.y = 0.95*scale;
      group.add(gem);
      group.userData.animParts.push({ mesh: gem, type: 'spin', speed: 2 });
      
      // Sparkle aura
      for (let i = 0; i < 6; i++) {
        const sparkle = new THREE.Mesh(new THREE.OctahedronGeometry(0.02*scale, 0), goldMat);
        const angle = (i / 6) * Math.PI * 2;
        sparkle.position.set(Math.cos(angle)*0.25*scale, 0.7*scale + Math.sin(angle*2)*0.1*scale, Math.sin(angle)*0.25*scale);
        group.add(sparkle);
        group.userData.animParts.push({ mesh: sparkle, type: 'orbit', offset: i, radius: 0.25*scale });
      }
      break;
  }
}

function buildSoccerTowerMesh(group, idx, scale, bodyMat, glowMat, metalMat, darkMat, whiteMat, goldMat, color) {
  group.userData.animParts = [];
  
  switch(idx) {
    case 0: // Striker - Soccer Player Kicking
      // Legs
      const legL = new THREE.Mesh(new THREE.CylinderGeometry(0.04*scale, 0.05*scale, 0.3*scale, 8), whiteMat);
      legL.position.set(-0.08*scale, 0.25*scale, 0);
      group.add(legL);
      
      const legR = new THREE.Mesh(new THREE.CylinderGeometry(0.04*scale, 0.05*scale, 0.3*scale, 8), whiteMat);
      legR.position.set(0.08*scale, 0.25*scale, 0.1*scale);
      legR.rotation.x = -0.5;
      group.add(legR);
      
      // Body
      const strikerBody = new THREE.Mesh(new THREE.CylinderGeometry(0.12*scale, 0.14*scale, 0.3*scale, 8), bodyMat);
      strikerBody.position.y = 0.5*scale;
      strikerBody.castShadow = true;
      group.add(strikerBody);
      
      // Head
      const strikerHead = new THREE.Mesh(new THREE.SphereGeometry(0.08*scale, 12, 12), whiteMat);
      strikerHead.position.y = 0.72*scale;
      group.add(strikerHead);
      
      // Boot
      const boot = new THREE.Mesh(new THREE.BoxGeometry(0.08*scale, 0.05*scale, 0.15*scale), bodyMat);
      boot.position.set(0.08*scale, 0.12*scale, 0.2*scale);
      group.add(boot);
      
      // Ball being kicked
      const ball = new THREE.Mesh(new THREE.SphereGeometry(0.07*scale, 16, 16), whiteMat);
      ball.position.set(0.1*scale, 0.15*scale, 0.35*scale);
      group.add(ball);
      group.userData.animParts.push({ mesh: ball, type: 'pulse' });
      
      // Ball pattern
      for (let i = 0; i < 6; i++) {
        const patch = new THREE.Mesh(new THREE.CircleGeometry(0.02*scale, 5), darkMat);
        const phi = Math.acos(-1 + (2 * i + 1) / 6);
        const theta = Math.sqrt(6 * Math.PI) * phi;
        patch.position.setFromSphericalCoords(0.072*scale, phi, theta);
        patch.position.x += 0.1*scale;
        patch.position.y += 0.15*scale;
        patch.position.z += 0.35*scale;
        patch.lookAt(0.1*scale, 0.15*scale, 0.35*scale);
        group.add(patch);
      }
      break;
      
    case 1: // Free Kick - Precision Kicker
      // Tee base
      const teeBase = new THREE.Mesh(new THREE.CylinderGeometry(0.2*scale, 0.25*scale, 0.12*scale, 12), darkMat);
      teeBase.position.y = 0.16*scale;
      teeBase.castShadow = true;
      group.add(teeBase);
      
      // Ball on tee
      const fkBall = new THREE.Mesh(new THREE.SphereGeometry(0.12*scale, 20, 20), whiteMat);
      fkBall.position.y = 0.35*scale;
      fkBall.castShadow = true;
      group.add(fkBall);
      
      // Ball pattern
      for (let i = 0; i < 12; i++) {
        const patch = new THREE.Mesh(new THREE.CircleGeometry(0.035*scale, 5), darkMat);
        const phi = Math.acos(-1 + (2 * i + 1) / 12);
        const theta = Math.sqrt(12 * Math.PI) * phi;
        patch.position.setFromSphericalCoords(0.122*scale, phi, theta);
        patch.position.y += 0.35*scale;
        patch.lookAt(0, 0.35*scale, 0);
        group.add(patch);
      }
      
      // Targeting system
      const targetArm = new THREE.Mesh(new THREE.BoxGeometry(0.04*scale, 0.04*scale, 0.4*scale), metalMat);
      targetArm.position.set(0, 0.55*scale, 0.2*scale);
      group.add(targetArm);
      
      // Laser sight
      const laserSight = new THREE.Mesh(new THREE.CylinderGeometry(0.008*scale, 0.008*scale, 0.6*scale, 4), new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.5 }));
      laserSight.position.set(0, 0.55*scale, 0.7*scale);
      laserSight.rotation.x = Math.PI/2;
      group.add(laserSight);
      group.userData.animParts.push({ mesh: laserSight, type: 'blink' });
      
      // Targeting reticle
      const reticle = new THREE.Mesh(new THREE.RingGeometry(0.08*scale, 0.1*scale, 24), glowMat);
      reticle.position.set(0, 0.55*scale, 1.0*scale);
      reticle.rotation.y = Math.PI/2;
      group.add(reticle);
      group.userData.animParts.push({ mesh: reticle, type: 'spin', speed: 1 });
      break;
      
    case 2: // Header - Jumping Player
      // Body diving
      const headerBody = new THREE.Mesh(new THREE.CylinderGeometry(0.12*scale, 0.14*scale, 0.35*scale, 8), bodyMat);
      headerBody.position.set(0, 0.45*scale, 0.1*scale);
      headerBody.rotation.x = 0.8;
      headerBody.castShadow = true;
      group.add(headerBody);
      
      // Head
      const headerHead = new THREE.Mesh(new THREE.SphereGeometry(0.1*scale, 12, 12), whiteMat);
      headerHead.position.set(0, 0.55*scale, 0.35*scale);
      headerHead.castShadow = true;
      group.add(headerHead);
      
      // Arms spread
      const armL = new THREE.Mesh(new THREE.CylinderGeometry(0.03*scale, 0.04*scale, 0.25*scale, 6), bodyMat);
      armL.position.set(-0.2*scale, 0.5*scale, 0.15*scale);
      armL.rotation.z = 0.8;
      group.add(armL);
      
      const armR = new THREE.Mesh(new THREE.CylinderGeometry(0.03*scale, 0.04*scale, 0.25*scale, 6), bodyMat);
      armR.position.set(0.2*scale, 0.5*scale, 0.15*scale);
      armR.rotation.z = -0.8;
      group.add(armR);
      
      // Impact effect
      for (let i = 0; i < 3; i++) {
        const impactRing = new THREE.Mesh(new THREE.TorusGeometry((0.12 + i*0.08)*scale, 0.012*scale, 6, 24), glowMat);
        impactRing.position.set(0, 0.55*scale, 0.45*scale);
        impactRing.rotation.x = Math.PI/2;
        impactRing.material = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.4 - i*0.1 });
        group.add(impactRing);
      }
      break;
      
    case 3: // Tackle - Sliding Player
      // Dust cloud base
      for (let i = 0; i < 5; i++) {
        const dust = new THREE.Mesh(new THREE.SphereGeometry((0.06 - i*0.01)*scale, 8, 8), new THREE.MeshBasicMaterial({ color: 0x8b7355, transparent: true, opacity: 0.4 - i*0.07 }));
        dust.position.set(-0.15*scale + i*0.08*scale, 0.12*scale, (Math.random()-0.5)*0.1*scale);
        group.add(dust);
      }
      
      // Sliding body
      const slideBody = new THREE.Mesh(new THREE.CylinderGeometry(0.1*scale, 0.12*scale, 0.3*scale, 8), bodyMat);
      slideBody.position.set(-0.05*scale, 0.22*scale, 0);
      slideBody.rotation.z = Math.PI/2;
      slideBody.castShadow = true;
      group.add(slideBody);
      
      // Extended leg
      const extLeg = new THREE.Mesh(new THREE.CylinderGeometry(0.04*scale, 0.05*scale, 0.35*scale, 8), whiteMat);
      extLeg.position.set(0.2*scale, 0.18*scale, 0);
      extLeg.rotation.z = Math.PI/2;
      group.add(extLeg);
      
      // Boot with studs
      const tackleBoot = new THREE.Mesh(new THREE.BoxGeometry(0.1*scale, 0.06*scale, 0.08*scale), bodyMat);
      tackleBoot.position.set(0.38*scale, 0.18*scale, 0);
      group.add(tackleBoot);
      
      // Studs glowing
      for (let i = 0; i < 4; i++) {
        const stud = new THREE.Mesh(new THREE.CylinderGeometry(0.012*scale, 0.015*scale, 0.03*scale, 6), glowMat);
        stud.position.set(0.38*scale, 0.14*scale, (i-1.5)*0.02*scale);
        group.add(stud);
      }
      break;
      
    case 4: // Keeper - Goalkeeper
      // Goal frame section
      const postL = new THREE.Mesh(new THREE.CylinderGeometry(0.03*scale, 0.03*scale, 0.6*scale, 8), whiteMat);
      postL.position.set(-0.25*scale, 0.4*scale, 0);
      group.add(postL);
      
      const postR = new THREE.Mesh(new THREE.CylinderGeometry(0.03*scale, 0.03*scale, 0.6*scale, 8), whiteMat);
      postR.position.set(0.25*scale, 0.4*scale, 0);
      group.add(postR);
      
      const crossbar = new THREE.Mesh(new THREE.CylinderGeometry(0.03*scale, 0.03*scale, 0.5*scale, 8), whiteMat);
      crossbar.position.y = 0.7*scale;
      crossbar.rotation.z = Math.PI/2;
      group.add(crossbar);
      
      // Keeper body diving
      const keeperBody = new THREE.Mesh(new THREE.CylinderGeometry(0.1*scale, 0.12*scale, 0.3*scale, 8), bodyMat);
      keeperBody.position.set(0.1*scale, 0.45*scale, 0.1*scale);
      keeperBody.rotation.z = -0.6;
      keeperBody.castShadow = true;
      group.add(keeperBody);
      
      // Gloves
      const gloveL2 = new THREE.Mesh(new THREE.BoxGeometry(0.1*scale, 0.12*scale, 0.06*scale), glowMat);
      gloveL2.position.set(-0.1*scale, 0.6*scale, 0.15*scale);
      group.add(gloveL2);
      
      const gloveR2 = new THREE.Mesh(new THREE.BoxGeometry(0.1*scale, 0.12*scale, 0.06*scale), glowMat);
      gloveR2.position.set(0.3*scale, 0.6*scale, 0.15*scale);
      group.add(gloveR2);
      group.userData.animParts.push({ mesh: gloveR2, type: 'reach' });
      break;
      
    case 5: // Playmaker - Passing Hub
      // Central platform
      const platform = new THREE.Mesh(new THREE.CylinderGeometry(0.2*scale, 0.25*scale, 0.15*scale, 12), darkMat);
      platform.position.y = 0.18*scale;
      platform.castShadow = true;
      group.add(platform);
      
      // Rotating hub
      const hub = new THREE.Mesh(new THREE.CylinderGeometry(0.1*scale, 0.1*scale, 0.1*scale, 12), metalMat);
      hub.position.y = 0.32*scale;
      group.add(hub);
      group.userData.animParts.push({ mesh: hub, type: 'spin', speed: 1 });
      
      // Orbital rings
      for (let i = 0; i < 2; i++) {
        const orbit = new THREE.Mesh(new THREE.TorusGeometry(0.25*scale, 0.01*scale, 8, 32), new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.4 }));
        orbit.position.y = 0.45*scale;
        orbit.rotation.x = Math.PI/2 + i*0.5;
        group.add(orbit);
      }
      
      // Orbiting balls
      for (let i = 0; i < 3; i++) {
        const orbitBall = new THREE.Mesh(new THREE.SphereGeometry(0.06*scale, 12, 12), whiteMat);
        const angle = (i / 3) * Math.PI * 2;
        orbitBall.position.set(Math.cos(angle)*0.25*scale, 0.45*scale, Math.sin(angle)*0.25*scale);
        group.add(orbitBall);
        group.userData.animParts.push({ mesh: orbitBall, type: 'orbit', offset: i, radius: 0.25*scale });
        
        // Ball pattern
        for (let j = 0; j < 3; j++) {
          const patch = new THREE.Mesh(new THREE.CircleGeometry(0.015*scale, 5), darkMat);
          const phi = Math.acos(-1 + (2 * j + 1) / 3);
          const theta = Math.sqrt(3 * Math.PI) * phi;
          patch.position.setFromSphericalCoords(0.062*scale, phi, theta);
          patch.position.x += orbitBall.position.x;
          patch.position.y += orbitBall.position.y;
          patch.position.z += orbitBall.position.z;
          patch.lookAt(orbitBall.position);
          group.add(patch);
        }
      }
      
      // Center energy core
      const core = new THREE.Mesh(new THREE.OctahedronGeometry(0.08*scale, 0), glowMat);
      core.position.y = 0.5*scale;
      group.add(core);
      group.userData.animParts.push({ mesh: core, type: 'pulse' });
      break;
      
    case 6: // Flare - Pyrotechnics
      // Flare launcher base
      const launcherBase = new THREE.Mesh(new THREE.CylinderGeometry(0.18*scale, 0.22*scale, 0.2*scale, 10), darkMat);
      launcherBase.position.y = 0.2*scale;
      launcherBase.castShadow = true;
      group.add(launcherBase);
      
      // Launch tubes
      for (let i = 0; i < 3; i++) {
        const tube = new THREE.Mesh(new THREE.CylinderGeometry(0.05*scale, 0.06*scale, 0.25*scale, 8), metalMat);
        tube.position.set((i-1)*0.1*scale, 0.42*scale, 0);
        tube.rotation.x = -0.2;
        group.add(tube);
      }
      
      // Flames shooting up
      const flareMat1 = new THREE.MeshBasicMaterial({ color: 0xff2200, transparent: true, opacity: 0.9 });
      const flareMat2 = new THREE.MeshBasicMaterial({ color: 0xff6600, transparent: true, opacity: 0.8 });
      
      for (let i = 0; i < 3; i++) {
        for (let j = 0; j < 3; j++) {
          const flare = new THREE.Mesh(new THREE.ConeGeometry((0.04 - j*0.01)*scale, (0.15 + j*0.1)*scale, 8), j % 2 === 0 ? flareMat1 : flareMat2);
          flare.position.set((i-1)*0.1*scale, (0.6 + j*0.1)*scale, 0.05*scale);
          group.add(flare);
          group.userData.animParts.push({ mesh: flare, type: 'flame', offset: i*3 + j });
        }
      }
      
      // Smoke particles
      for (let i = 0; i < 4; i++) {
        const smoke = new THREE.Mesh(new THREE.SphereGeometry(0.04*scale, 6, 6), new THREE.MeshBasicMaterial({ color: 0x555555, transparent: true, opacity: 0.3 }));
        smoke.position.set((Math.random()-0.5)*0.2*scale, 0.9*scale + i*0.08*scale, (Math.random()-0.5)*0.1*scale);
        group.add(smoke);
        group.userData.animParts.push({ mesh: smoke, type: 'float', offset: i });
      }
      break;
      
    case 7: // Legend - Golden Trophy Player
      // Pedestal
      const legendPed = new THREE.Mesh(new THREE.BoxGeometry(0.4*scale, 0.12*scale, 0.4*scale), darkMat);
      legendPed.position.y = 0.16*scale;
      legendPed.castShadow = true;
      group.add(legendPed);
      
      // Plaque
      const plaque = new THREE.Mesh(new THREE.BoxGeometry(0.3*scale, 0.06*scale, 0.02*scale), goldMat);
      plaque.position.set(0, 0.18*scale, 0.2*scale);
      group.add(plaque);
      
      // Golden figure base
      const figBase = new THREE.Mesh(new THREE.CylinderGeometry(0.12*scale, 0.15*scale, 0.08*scale, 12), goldMat);
      figBase.position.y = 0.27*scale;
      group.add(figBase);
      
      // Figure body
      const figBody = new THREE.Mesh(new THREE.CylinderGeometry(0.08*scale, 0.1*scale, 0.3*scale, 8), goldMat);
      figBody.position.y = 0.48*scale;
      figBody.castShadow = true;
      group.add(figBody);
      
      // Figure head
      const figHead = new THREE.Mesh(new THREE.SphereGeometry(0.07*scale, 12, 12), goldMat);
      figHead.position.y = 0.7*scale;
      group.add(figHead);
      
      // Arms raised in victory
      const figArmL = new THREE.Mesh(new THREE.CylinderGeometry(0.025*scale, 0.03*scale, 0.2*scale, 6), goldMat);
      figArmL.position.set(-0.12*scale, 0.7*scale, 0);
      figArmL.rotation.z = 0.6;
      group.add(figArmL);
      
      const figArmR = new THREE.Mesh(new THREE.CylinderGeometry(0.025*scale, 0.03*scale, 0.2*scale, 6), goldMat);
      figArmR.position.set(0.12*scale, 0.7*scale, 0);
      figArmR.rotation.z = -0.6;
      group.add(figArmR);
      
      // Crown
      const legendCrown = new THREE.Mesh(new THREE.CylinderGeometry(0.08*scale, 0.06*scale, 0.05*scale, 6), goldMat);
      legendCrown.position.y = 0.8*scale;
      group.add(legendCrown);
      
      for (let i = 0; i < 5; i++) {
        const crownSpike = new THREE.Mesh(new THREE.ConeGeometry(0.015*scale, 0.06*scale, 4), goldMat);
        const angle = (i / 5) * Math.PI * 2;
        crownSpike.position.set(Math.cos(angle)*0.05*scale, 0.86*scale, Math.sin(angle)*0.05*scale);
        group.add(crownSpike);
      }
      
      // Aura rings
      for (let i = 0; i < 3; i++) {
        const aura = new THREE.Mesh(new THREE.TorusGeometry((0.2 + i*0.1)*scale, 0.01*scale, 8, 32), new THREE.MeshBasicMaterial({ color: 0xffd700, transparent: true, opacity: 0.3 - i*0.08 }));
        aura.position.y = (0.5 + i*0.15)*scale;
        aura.rotation.x = Math.PI/2;
        group.add(aura);
        group.userData.animParts.push({ mesh: aura, type: 'pulse', offset: i });
      }
      
      // Sparkles
      for (let i = 0; i < 8; i++) {
        const sparkle = new THREE.Mesh(new THREE.OctahedronGeometry(0.02*scale, 0), goldMat);
        const angle = (i / 8) * Math.PI * 2;
        sparkle.position.set(Math.cos(angle)*0.3*scale, 0.5*scale + Math.sin(angle*2)*0.15*scale, Math.sin(angle)*0.3*scale);
        group.add(sparkle);
        group.userData.animParts.push({ mesh: sparkle, type: 'orbit', offset: i, radius: 0.3*scale });
      }
      break;
  }
}

// ========================================
// ENHANCED ENEMY CREATION
// ========================================
function createEnemyMesh(enemy) {
  const hw = COLS/2, hh = ROWS/2;
  const group = new THREE.Group();
  const isHockey = theme === 'hockey';
  const sz = (enemy.sz || 1) * 0.28;
  
  // Materials
  const bodyMat = new THREE.MeshStandardMaterial({ 
    color: enemy.fire ? 0xff3300 : (isHockey ? 0x111111 : 0xffffff),
    metalness: 0.3,
    roughness: 0.6
  });
  
  if (isHockey) {
    // === PUCK ===
    // Main puck body
    const puckBody = new THREE.Mesh(new THREE.CylinderGeometry(sz, sz, sz * 0.3, 32), bodyMat);
    puckBody.rotation.x = Math.PI/2;
    puckBody.castShadow = true;
    group.add(puckBody);
    
    // Edge detail
    const edgeRing = new THREE.Mesh(new THREE.TorusGeometry(sz, sz * 0.06, 8, 32), new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.5, roughness: 0.5 }));
    edgeRing.rotation.x = Math.PI/2;
    group.add(edgeRing);
    
    // Team logo (simple circle)
    if (!enemy.fire) {
      const logo = new THREE.Mesh(new THREE.CircleGeometry(sz * 0.5, 16), new THREE.MeshBasicMaterial({ color: 0x00d4ff }));
      logo.position.z = sz * 0.16;
      group.add(logo);
    }
    
    // Boss crown
    if (enemy.boss) {
      const crownBase = new THREE.Mesh(new THREE.TorusGeometry(sz * 0.6, 0.05, 8, 16), new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.9, roughness: 0.1 }));
      crownBase.position.y = sz * 0.25;
      crownBase.rotation.x = Math.PI/2;
      group.add(crownBase);
      
      for (let i = 0; i < 5; i++) {
        const spike = new THREE.Mesh(new THREE.ConeGeometry(0.05, sz * 0.4, 4), new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.9, roughness: 0.1 }));
        const angle = (i / 5) * Math.PI * 2;
        spike.position.set(Math.cos(angle) * sz * 0.6, sz * 0.45, Math.sin(angle) * sz * 0.6);
        group.add(spike);
      }
      
      // Center gem
      const gem = new THREE.Mesh(new THREE.OctahedronGeometry(0.08, 0), new THREE.MeshBasicMaterial({ color: 0xff0000 }));
      gem.position.y = sz * 0.55;
      group.add(gem);
      enemy.crownGem = gem;
    }
  } else {
    // === SOCCER BALL ===
    // Main ball body
    const ballBody = new THREE.Mesh(new THREE.SphereGeometry(sz, 24, 24), bodyMat);
    ballBody.castShadow = true;
    group.add(ballBody);
    
    // Pentagon patches
    if (!enemy.fire) {
      const patchMat = new THREE.MeshBasicMaterial({ color: 0x111111 });
      const pentagonPositions = [
        [0, 1, 0], [0, -1, 0],
        [0.894, 0.447, 0], [0.276, 0.447, 0.851], [-0.724, 0.447, 0.526],
        [-0.724, 0.447, -0.526], [0.276, 0.447, -0.851],
        [0.724, -0.447, 0.526], [-0.276, -0.447, 0.851], [-0.894, -0.447, 0],
        [-0.276, -0.447, -0.851], [0.724, -0.447, -0.526]
      ];
      
      pentagonPositions.forEach(([px, py, pz]) => {
        const patch = new THREE.Mesh(new THREE.CircleGeometry(sz * 0.32, 5), patchMat);
        patch.position.set(px * sz * 1.01, py * sz * 1.01, pz * sz * 1.01);
        patch.lookAt(0, 0, 0);
        patch.rotateZ(Math.PI / 5);
        group.add(patch);
      });
    }
    
    // Boss crown
    if (enemy.boss) {
      const crownBase = new THREE.Mesh(new THREE.TorusGeometry(sz * 0.7, 0.06, 8, 16), new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.9, roughness: 0.1 }));
      crownBase.position.y = sz * 0.8;
      crownBase.rotation.x = Math.PI/2;
      group.add(crownBase);
      
      for (let i = 0; i < 5; i++) {
        const spike = new THREE.Mesh(new THREE.ConeGeometry(0.06, sz * 0.5, 4), new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.9, roughness: 0.1 }));
        const angle = (i / 5) * Math.PI * 2;
        spike.position.set(Math.cos(angle) * sz * 0.7, sz * 1.05, Math.sin(angle) * sz * 0.7);
        group.add(spike);
      }
      
      const gem = new THREE.Mesh(new THREE.OctahedronGeometry(0.1, 0), new THREE.MeshBasicMaterial({ color: 0xff0000 }));
      gem.position.y = sz * 1.2;
      group.add(gem);
      enemy.crownGem = gem;
    }
  }
  
  // === FIRE EFFECTS ===
  if (enemy.fire) {
    const flameCount = enemy.boss ? 12 : 6;
    enemy.flames = [];
    
    for (let i = 0; i < flameCount; i++) {
      const flame = new THREE.Mesh(
        new THREE.ConeGeometry(sz * 0.2, sz * 0.5, 8),
        new THREE.MeshBasicMaterial({ color: i % 2 === 0 ? 0xff4400 : 0xffaa00, transparent: true, opacity: 0.85 })
      );
      const angle = (i / flameCount) * Math.PI * 2;
      flame.position.set(Math.cos(angle) * sz * 0.6, sz * 0.3, Math.sin(angle) * sz * 0.6);
      group.add(flame);
      enemy.flames.push(flame);
    }
    
    // Inner flames
    for (let i = 0; i < 4; i++) {
      const innerFlame = new THREE.Mesh(
        new THREE.ConeGeometry(sz * 0.15, sz * 0.6, 6),
        new THREE.MeshBasicMaterial({ color: 0xffcc00, transparent: true, opacity: 0.9 })
      );
      const angle = (i / 4) * Math.PI * 2 + 0.4;
      innerFlame.position.set(Math.cos(angle) * sz * 0.3, sz * 0.35, Math.sin(angle) * sz * 0.3);
      group.add(innerFlame);
      enemy.flames.push(innerFlame);
    }
  }
  
  // === FLYING WINGS ===
  if (enemy.flying) {
    enemy.wings = [];
    const wingMat = new THREE.MeshBasicMaterial({ color: 0x88ccff, transparent: true, opacity: 0.7, side: THREE.DoubleSide });
    
    [-1, 1].forEach(side => {
      // Main wing
      const wingShape = new THREE.Shape();
      wingShape.moveTo(0, 0);
      wingShape.quadraticCurveTo(sz * 0.7, sz * 0.3, sz * 1.2, 0);
      wingShape.quadraticCurveTo(sz * 0.7, -sz * 0.2, 0, 0);
      
      const wingGeo = new THREE.ShapeGeometry(wingShape);
      const wing = new THREE.Mesh(wingGeo, wingMat);
      wing.position.set(side * sz * 0.5, sz * 0.2, 0);
      wing.rotation.y = side * 0.3;
      wing.scale.x = side;
      group.add(wing);
      enemy.wings.push(wing);
    });
  }
  
  // === ARMOR PLATES ===
  if (enemy.armor > 0 && !enemy.boss) {
    const armorMat = new THREE.MeshStandardMaterial({ color: 0x666677, metalness: 0.7, roughness: 0.3 });
    for (let i = 0; i < 4; i++) {
      const plate = new THREE.Mesh(new THREE.BoxGeometry(sz * 0.4, sz * 0.4, 0.04), armorMat);
      const angle = (i / 4) * Math.PI * 2 + Math.PI/4;
      plate.position.set(Math.cos(angle) * sz * 0.95, 0, Math.sin(angle) * sz * 0.95);
      plate.lookAt(0, 0, 0);
      plate.castShadow = true;
      group.add(plate);
    }
    
    // Rivets
    for (let i = 0; i < 8; i++) {
      const rivet = new THREE.Mesh(new THREE.SphereGeometry(0.02, 6, 6), new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.9, roughness: 0.1 }));
      const angle = (i / 8) * Math.PI * 2;
      rivet.position.set(Math.cos(angle) * sz * 1.05, Math.sin(angle * 2) * sz * 0.15, Math.sin(angle) * sz * 1.05);
      group.add(rivet);
    }
  }
  
  // === HEALTH BAR ===
  const hpBgGeo = new THREE.PlaneGeometry(sz * 2.2, 0.12);
  const hpBg = new THREE.Mesh(hpBgGeo, new THREE.MeshBasicMaterial({ color: 0x222222, side: THREE.DoubleSide }));
  hpBg.position.y = sz * 1.5;
  hpBg.rotation.x = -Math.PI / 2;
  group.add(hpBg);
  
  const hpBarGeo = new THREE.PlaneGeometry(sz * 2, 0.08);
  const hpBar = new THREE.Mesh(hpBarGeo, new THREE.MeshBasicMaterial({ color: 0x22c55e, side: THREE.DoubleSide }));
  hpBar.position.y = sz * 1.51;
  hpBar.rotation.x = -Math.PI / 2;
  group.add(hpBar);
  enemy.hpBar = hpBar;
  enemy.hpSize = sz * 2;
  
  group.position.set(enemy.x, enemy.flying ? 1.2 : 0.2, enemy.z);
  scene.add(group);
  return group;
}

// Animation update for towers and enemies
function updateAnimations(dt) {
  const t = animTime;
  
  // Animate towers
  towers.forEach(tw => {
    if (!tw.animParts) return;
    tw.animParts.forEach(part => {
      if (!part.mesh) return;
      
      switch(part.type) {
        case 'pulse':
          const pulseScale = 1 + Math.sin(t * 4 + (part.offset || 0)) * 0.15;
          part.mesh.scale.setScalar(pulseScale);
          break;
        case 'spin':
          part.mesh.rotation.y += dt * (part.speed || 1) * 2;
          break;
        case 'float':
          part.mesh.position.y += Math.sin(t * 3 + (part.offset || 0)) * 0.003;
          break;
        case 'flame':
          const flameScale = 0.8 + Math.sin(t * 10 + (part.offset || 0) * 0.5) * 0.3;
          part.mesh.scale.y = flameScale;
          part.mesh.scale.x = 0.9 + Math.sin(t * 8 + (part.offset || 0)) * 0.2;
          break;
        case 'orbit':
          const orbitAngle = t * 1.5 + (part.offset || 0) * (Math.PI * 2 / 3);
          part.mesh.position.x = Math.cos(orbitAngle) * (part.radius || 0.25);
          part.mesh.position.z = Math.sin(orbitAngle) * (part.radius || 0.25);
          break;
        case 'blink':
          part.mesh.visible = Math.sin(t * 5) > 0;
          break;
        case 'punch':
          part.mesh.position.z = 0.1 + Math.abs(Math.sin(t * 3 + part.side)) * 0.15;
          break;
        case 'reach':
          part.mesh.position.x = 0.3 + Math.sin(t * 2) * 0.1;
          part.mesh.position.y = 0.6 + Math.cos(t * 2) * 0.05;
          break;
      }
    });
  });
  
  // Animate enemies
  enemies.forEach(e => {
    // Animate flames
    if (e.flames) {
      e.flames.forEach((flame, i) => {
        const flameScale = 0.7 + Math.sin(t * 12 + i * 0.8) * 0.4;
        flame.scale.y = flameScale;
        flame.scale.x = 0.85 + Math.sin(t * 10 + i) * 0.25;
      });
    }
    
    // Animate wings
    if (e.wings) {
      e.wings.forEach((wing, i) => {
        wing.rotation.z = Math.sin(t * 8) * 0.3 * (i === 0 ? 1 : -1);
      });
    }
    
    // Animate boss crown gem
    if (e.crownGem) {
      e.crownGem.rotation.y += dt * 3;
      const gemScale = 1 + Math.sin(t * 4) * 0.2;
      e.crownGem.scale.setScalar(gemScale);
    }
    
    // Rolling animation for enemies
    if (e.mesh && !e.flying) {
      e.mesh.rotation.z += e.spd * dt * 2;
    }
  });
}

function updateCamera() {
  camera.position.x = Math.sin(camAngle) * camDist;
  camera.position.z = Math.cos(camAngle) * camDist;
  camera.position.y = camHeight;
  camera.lookAt(0, 0, 0);
}

function zoomIn() { camDist = Math.max(8, camDist - 2); camHeight = Math.max(5, camHeight - 1); updateCamera(); }
function zoomOut() { camDist = Math.min(40, camDist + 2); camHeight = Math.min(30, camHeight + 1); updateCamera(); }
function resetCam() { camAngle = Math.PI/4; camHeight = camDist * 0.6; updateCamera(); }

function onTouchStart(e) {
  e.preventDefault();
  if (e.touches.length === 1) {
    dragging = true; dragMoved = false;
    lastX = e.touches[0].clientX; lastY = e.touches[0].clientY;
    touchStart = Date.now();
  } else if (e.touches.length === 2) {
    const dx = e.touches[0].clientX - e.touches[1].clientX;
    const dy = e.touches[0].clientY - e.touches[1].clientY;
    touchStart = Math.sqrt(dx*dx + dy*dy);
  }
}

function onTouchMove(e) {
  e.preventDefault();
  if (e.touches.length === 1 && dragging) {
    const dx = e.touches[0].clientX - lastX;
    const dy = e.touches[0].clientY - lastY;
    if (Math.abs(dx) > 3 || Math.abs(dy) > 3) dragMoved = true;
    camAngle -= dx * 0.008;
    camHeight = Math.max(5, Math.min(30, camHeight - dy * 0.05));
    updateCamera();
    lastX = e.touches[0].clientX; lastY = e.touches[0].clientY;
  } else if (e.touches.length === 2) {
    const dx = e.touches[0].clientX - e.touches[1].clientX;
    const dy = e.touches[0].clientY - e.touches[1].clientY;
    const dist = Math.sqrt(dx*dx + dy*dy);
    camDist = Math.max(8, Math.min(40, camDist - (dist - touchStart) * 0.04));
    updateCamera();
    touchStart = dist;
  }
}

function onTouchEnd(e) {
  if (!dragMoved && Date.now() - touchStart < 200) handleTap(e.changedTouches[0]);
  dragging = false;
}

function onMouseDown(e) { dragging = true; dragMoved = false; lastX = e.clientX; lastY = e.clientY; }
function onMouseMove(e) {
  if (!dragging) return;
  const dx = e.clientX - lastX, dy = e.clientY - lastY;
  if (Math.abs(dx) > 2 || Math.abs(dy) > 2) dragMoved = true;
  camAngle -= dx * 0.008;
  camHeight = Math.max(5, Math.min(30, camHeight - dy * 0.05));
  updateCamera();
  lastX = e.clientX; lastY = e.clientY;
}
function onMouseUp() { dragging = false; }
function onWheel(e) { e.preventDefault(); e.deltaY > 0 ? zoomOut() : zoomIn(); }
function onClick(e) { if (!dragMoved) handleTap(e); }

function handleTap(e) {
  const rect = renderer.domElement.getBoundingClientRect();
  mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
  
  raycaster.setFromCamera(mouse, camera);
  const hits = raycaster.intersectObjects(cells);
  if (hits.length > 0) {
    const { x, y } = hits[0].object.userData;
    handleCellTap(x, y);
  }
}

function handleCellTap(x, y) {
  const cell = grid[y][x];
  
  if (sellMode && cell.tower) {
    let val = Math.floor(themeData.towers.find(t => t.id === cell.tower.type).cost * 0.6);
    for (let i = 0; i < cell.tower.lv; i++) val += Math.floor(themeData.towers.find(t => t.id === cell.tower.type).up[i] * 0.6);
    money += val;
    if (cell.tower.mesh) scene.remove(cell.tower.mesh);
    towers.splice(towers.indexOf(cell.tower), 1);
    cell.tower = null;
    hideUpgrade();
    updateHUD();
    return;
  }
  
  if (cell.tower) { showUpgrade(cell.tower); return; }
  hideUpgrade();
  
  if (selectedTower && cell.type === 'ground') {
    const td = themeData.towers.find(t => t.id === selectedTower);
    if (money >= td.cost) {
      const tower = { type: selectedTower, x, y, lv: 0, dmg: td.dmg[0], rng: td.rng[0], rate: td.rate[0], lastShot: 0 };
      if (td.splash) tower.splash = td.splash[0];
      if (td.slow) { tower.slow = td.slow; tower.slowDur = td.slowDur[0]; }
      if (td.chain) { tower.chain = td.chain[0]; tower.chainRng = td.chainRng; }
      if (td.burn) { tower.burn = td.burn[0]; tower.burnDur = td.burnDur; }
      if (td.crit) tower.crit = td.crit;
      
      tower.mesh = createTowerMesh(tower);
      towers.push(tower);
      cell.tower = tower;
      money -= td.cost;
      updateHUD();
    }
  }
}

function renderTowers() {
  const bar = document.getElementById('towerBar');
  bar.innerHTML = '';
  themeData.towers.forEach(t => {
    const btn = document.createElement('div');
    btn.className = 'tower-btn' + (money < t.cost ? ' disabled' : '') + (selectedTower === t.id ? ' selected' : '');
    btn.style.setProperty('--c', t.clr);
    btn.innerHTML = `<div class="tower-btn-icon">${t.icon}</div><div class="tower-btn-name">${t.nm}</div><div class="tower-btn-cost">$${t.cost}</div>`;
    btn.onclick = () => {
      if (money >= t.cost) {
        selectedTower = selectedTower === t.id ? null : t.id;
        sellMode = false;
        document.getElementById('sellBtn').classList.remove('active');
        hideUpgrade();
        renderTowers();
      }
    };
    bar.appendChild(btn);
  });
}

function updateHUD() {
  document.getElementById('moneyVal').textContent = money;
  document.getElementById('waveNum').textContent = wave;
  document.getElementById('waveMax').textContent = mapData.waves;
  document.getElementById('livesVal').textContent = lives;
  document.getElementById('scoreVal').textContent = score;
  document.getElementById('startBtn').disabled = waveActive;
  renderTowers();
}

function toggleSell() {
  sellMode = !sellMode;
  selectedTower = null;
  document.getElementById('sellBtn').classList.toggle('active', sellMode);
  hideUpgrade();
  renderTowers();
}

function showUpgrade(tower) {
  selectedPlaced = tower;
  const td = themeData.towers.find(t => t.id === tower.type);
  
  document.getElementById('upIcon').textContent = td.icon;
  document.getElementById('upName').textContent = td.nm;
  document.getElementById('upLevel').textContent = 'Level ' + (tower.lv + 1);
  document.getElementById('upDmg').textContent = td.dmg[tower.lv];
  document.getElementById('upRng').textContent = td.rng[tower.lv].toFixed(1);
  document.getElementById('upRate').textContent = td.rate[tower.lv].toFixed(2);
  
  let sellVal = Math.floor(td.cost * 0.6);
  for (let i = 0; i < tower.lv; i++) sellVal += Math.floor(td.up[i] * 0.6);
  document.getElementById('upSell').textContent = sellVal;
  
  if (tower.lv >= 3) {
    document.getElementById('upDmgNext').textContent = 'MAX';
    document.getElementById('upRngNext').textContent = 'MAX';
    document.getElementById('upRateNext').textContent = 'MAX';
    document.getElementById('upBtn').disabled = true;
    document.getElementById('upCost').textContent = '---';
  } else {
    document.getElementById('upDmgNext').textContent = '‚Üí' + td.dmg[tower.lv + 1];
    document.getElementById('upRngNext').textContent = '‚Üí' + td.rng[tower.lv + 1].toFixed(1);
    document.getElementById('upRateNext').textContent = '‚Üí' + td.rate[tower.lv + 1].toFixed(2);
    document.getElementById('upCost').textContent = td.up[tower.lv];
    document.getElementById('upBtn').disabled = money < td.up[tower.lv];
  }
  
  document.getElementById('upgradeSheet').classList.add('show');
}

function hideUpgrade() {
  document.getElementById('upgradeSheet').classList.remove('show');
  selectedPlaced = null;
}

function doUpgrade() {
  if (!selectedPlaced || selectedPlaced.lv >= 3) return;
  const td = themeData.towers.find(t => t.id === selectedPlaced.type);
  if (money < td.up[selectedPlaced.lv]) return;
  
  money -= td.up[selectedPlaced.lv];
  selectedPlaced.lv++;
  selectedPlaced.dmg = td.dmg[selectedPlaced.lv];
  selectedPlaced.rng = td.rng[selectedPlaced.lv];
  selectedPlaced.rate = td.rate[selectedPlaced.lv];
  
  if (td.splash) selectedPlaced.splash = td.splash[selectedPlaced.lv];
  if (td.slowDur) selectedPlaced.slowDur = td.slowDur[selectedPlaced.lv];
  if (td.chain) selectedPlaced.chain = td.chain[selectedPlaced.lv];
  if (td.burn) selectedPlaced.burn = td.burn[selectedPlaced.lv];
  
  if (selectedPlaced.rangeMesh) selectedPlaced.rangeMesh.geometry = new THREE.RingGeometry(selectedPlaced.rng - 0.05, selectedPlaced.rng, 64);
  
  // Rebuild mesh
  if (selectedPlaced.mesh) scene.remove(selectedPlaced.mesh);
  selectedPlaced.mesh = createTowerMesh(selectedPlaced);
  
  updateHUD();
  showUpgrade(selectedPlaced);
}

function sellTower() {
  if (!selectedPlaced) return;
  const td = themeData.towers.find(t => t.id === selectedPlaced.type);
  let val = Math.floor(td.cost * 0.6);
  for (let i = 0; i < selectedPlaced.lv; i++) val += Math.floor(td.up[i] * 0.6);
  money += val;
  
  const cell = grid[selectedPlaced.y][selectedPlaced.x];
  if (selectedPlaced.mesh) scene.remove(selectedPlaced.mesh);
  towers.splice(towers.indexOf(selectedPlaced), 1);
  cell.tower = null;
  hideUpgrade();
  updateHUD();
}

function startWave() {
  if (waveActive || wave >= mapData.waves) return;
  waveActive = true;
  wave++;
  updateHUD();
  
  const waveData = WAVES[wave - 1];
  const hw = COLS/2, hh = ROWS/2;
  let delay = 0;
  
  Object.entries(waveData).forEach(([id, count]) => {
    const ed = themeData.enemies.find(e => e.id === id);
    if (!ed) return;
    for (let i = 0; i < count; i++) {
      setTimeout(() => spawnEnemy(ed), delay);
      delay += 450;
    }
  });
}

function spawnEnemy(ed) {
  const hw = COLS/2, hh = ROWS/2;
  const e = {
    type: ed.id,
    x: PATH[0][0] - hw + 0.5,
    y: 0.2,
    z: PATH[0][1] - hh + 0.5,
    hp: ed.hp * (1 + wave * 0.12),
    maxHp: ed.hp * (1 + wave * 0.12),
    spd: ed.spd,
    rwd: ed.rwd,
    sz: ed.sz || 1,
    armor: ed.armor || 0,
    fire: ed.fire || false,
    flying: ed.flying || false,
    boss: ed.boss || false,
    pathIdx: 0,
    slow: 0,
    burnT: 0,
    burnD: 0
  };
  
  e.mesh = createEnemyMesh(e);
  enemies.push(e);
}

function gameLoop(t) {
  if (!running) return;
  
  resizeRendererToDisplaySize();
  const dt = Math.min((t - lastTime) / 1000, 0.1) * gameSpeed;
  lastTime = t;
  animTime += dt;
  
  updateEnemies(dt);
  updateTowers(t);
  updateProjectiles(dt);
  updateParticles(dt);
  updateAnimations(dt);
  
  renderer.render(scene, camera);
  
  if (waveActive && enemies.length === 0 && projectiles.length === 0) {
    waveActive = false;
    updateHUD();
    const mapProgress = getMapProgress(theme, currentMapIndex);
    if (mapProgress) mapProgress.bestScore = Math.max(mapProgress.bestScore, score);
    persistSave();
    
    if (wave >= mapData.waves) {
      document.getElementById('winScore').textContent = score;
      document.getElementById('winWaves').textContent = wave;
      document.getElementById('winModal').classList.add('show');
      recordGameResult(true);
      running = false;
      return;
    }
  }
  
  requestAnimationFrame(gameLoop);
}

function updateEnemies(dt) {
  const hw = COLS/2, hh = ROWS/2;
  
  for (let i = enemies.length - 1; i >= 0; i--) {
    const e = enemies[i];
    
    if (e.slow > 0) e.slow -= dt;
    if (e.burnT > 0) { e.burnT -= dt; e.hp -= e.burnD * dt; }
    
    const spd = e.spd * (e.slow > 0 ? 0.5 : 1) * dt;
    
    if (e.pathIdx < PATH.length) {
      const tx = PATH[e.pathIdx][0] - hw + 0.5;
      const tz = PATH[e.pathIdx][1] - hh + 0.5;
      const dx = tx - e.x, dz = tz - e.z;
      const dist = Math.sqrt(dx*dx + dz*dz);
      
      if (dist <= spd) { e.x = tx; e.z = tz; e.pathIdx++; }
      else { e.x += (dx/dist)*spd; e.z += (dz/dist)*spd; }
      
      if (e.mesh) {
        e.mesh.position.set(e.x, e.flying ? 1.2 : 0.2, e.z);
        if (dist > 0.01) e.mesh.rotation.y = Math.atan2(dx, dz);
      }
    } else {
      lives--;
      removeEnemy(e, i);
      updateHUD();
      
      if (lives <= 0) {
        document.getElementById('loseWave').textContent = wave;
        document.getElementById('loseScore').textContent = score;
        document.getElementById('loseModal').classList.add('show');
        recordGameResult(false);
        running = false;
        waveActive = false;
      }
      continue;
    }
    
    if (e.hpBar) {
      const ratio = Math.max(0, e.hp / e.maxHp);
      e.hpBar.scale.x = ratio;
      e.hpBar.material.color.setHex(ratio > 0.5 ? 0x22c55e : ratio > 0.25 ? 0xfbbf24 : 0xef4444);
    }
    
    if (e.hp <= 0) {
      money += e.rwd;
      score += e.rwd * 10;
      createExplosion(e.x, e.y, e.z, e.fire);
      removeEnemy(e, i);
      updateHUD();
    }
  }
}

function removeEnemy(e, i) {
  if (e.mesh) scene.remove(e.mesh);
  enemies.splice(i, 1);
}

function updateTowers(t) {
  const hw = COLS/2, hh = ROWS/2;
  
  towers.forEach(tw => {
    if (t - tw.lastShot < 1000 / tw.rate / gameSpeed) return;
    
    const tx = tw.x - hw + 0.5;
    const tz = tw.y - hh + 0.5;
    
    let target = null, bestScore = -Infinity;
    enemies.forEach(e => {
      const dx = e.x - tx, dz = e.z - tz;
      const dist = Math.sqrt(dx*dx + dz*dz);
      if (dist < tw.rng) {
        const score = e.pathIdx * 100 - dist + (e.boss ? 500 : 0);
        if (score > bestScore) { bestScore = score; target = e; }
      }
    });
    
    if (target) {
      createProjectile(tw, target, tx, tz);
      tw.lastShot = t;
      
      if (tw.mesh) {
        const angle = Math.atan2(target.x - tx, target.z - tz);
        tw.mesh.rotation.y = angle;
      }
    }
  });
}

function createProjectile(tw, target, sx, sz) {
  const td = themeData.towers.find(t => t.id === tw.type);
  const proj = { x: sx, y: 0.5, z: sz, tx: target.x, ty: target.y, tz: target.z, target, tower: tw, speed: 14 };
  
  // Create projectile based on tower type
  let geo, mat;
  const towerIdx = parseInt(tw.type.substring(1)) - 1;
  
  if (theme === 'hockey') {
    if (towerIdx === 0) { // Slap shot - puck
      geo = new THREE.CylinderGeometry(0.08, 0.08, 0.03, 12);
      geo.rotateX(Math.PI/2);
    } else if (towerIdx === 6) { // Fire - flame
      geo = new THREE.ConeGeometry(0.06, 0.15, 8);
    } else {
      geo = new THREE.SphereGeometry(0.08, 8, 8);
    }
  } else {
    if (towerIdx === 0 || towerIdx === 1) { // Striker/Free kick - ball
      geo = new THREE.SphereGeometry(0.1, 12, 12);
    } else if (towerIdx === 6) { // Flare - flame
      geo = new THREE.ConeGeometry(0.06, 0.15, 8);
    } else {
      geo = new THREE.SphereGeometry(0.08, 8, 8);
    }
  }
  
  mat = new THREE.MeshBasicMaterial({ color: new THREE.Color(td.clr) });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.set(sx, 0.5, sz);
  scene.add(mesh);
  proj.mesh = mesh;
  projectiles.push(proj);
}

function updateProjectiles(dt) {
  for (let i = projectiles.length - 1; i >= 0; i--) {
    const p = projectiles[i];
    if (enemies.includes(p.target)) { p.tx = p.target.x; p.ty = p.target.y; p.tz = p.target.z; }
    
    const dx = p.tx - p.x, dy = p.ty - p.y, dz = p.tz - p.z;
    const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
    const move = p.speed * dt;
    
    if (dist <= move) {
      handleHit(p);
      if (p.mesh) scene.remove(p.mesh);
      projectiles.splice(i, 1);
    } else {
      p.x += (dx/dist)*move;
      p.y += (dy/dist)*move;
      p.z += (dz/dist)*move;
      if (p.mesh) {
        p.mesh.position.set(p.x, p.y, p.z);
        p.mesh.rotation.y += dt * 10; // Spin
      }
    }
  }
}

function handleHit(p) {
  const tw = p.tower;
  let dmg = tw.dmg;
  
  if (tw.crit && Math.random() < tw.crit) { dmg *= 3; createExplosion(p.x, p.y, p.z, false, 0xffd700); }
  
  if (tw.splash) {
    enemies.forEach(e => {
      const dx = e.x - p.x, dz = e.z - p.z;
      const dist = Math.sqrt(dx*dx + dz*dz);
      if (dist < tw.splash) hurtEnemy(e, dmg * (1 - dist/tw.splash/2));
    });
    createExplosion(p.x, p.y, p.z, false);
  } else if (tw.chain && p.target && enemies.includes(p.target)) {
    let current = p.target;
    hurtEnemy(current, dmg);
    for (let c = 0; c < tw.chain; c++) {
      let next = null, minDist = tw.chainRng;
      enemies.forEach(e => {
        if (e === current) return;
        const dx = e.x - current.x, dz = e.z - current.z;
        const dist = Math.sqrt(dx*dx + dz*dz);
        if (dist < minDist) { minDist = dist; next = e; }
      });
      if (next) { createLightning(current.x, current.z, next.x, next.z); hurtEnemy(next, dmg * 0.5); current = next; }
    }
  } else if (p.target && enemies.includes(p.target)) {
    hurtEnemy(p.target, dmg);
    if (tw.slow) p.target.slow = tw.slowDur;
    if (tw.burn) { p.target.burnT = tw.burnDur; p.target.burnD = tw.burn; }
  }
}

function hurtEnemy(e, dmg) { e.hp -= dmg * (1 - e.armor); }

function createExplosion(x, y, z, isFire, color) {
  const c = color || (isFire ? 0xff4400 : 0xff8800);
  for (let i = 0; i < 8; i++) {
    const p = { x, y, z, vx: (Math.random()-0.5)*4, vy: Math.random()*4+2, vz: (Math.random()-0.5)*4, life: 0.5 };
    const mesh = new THREE.Mesh(new THREE.SphereGeometry(0.06, 6, 6), new THREE.MeshBasicMaterial({ color: c }));
    mesh.position.set(x, y, z);
    scene.add(mesh);
    p.mesh = mesh;
    particles.push(p);
  }
}

function createLightning(x1, z1, x2, z2) {
  const dx = x2-x1, dz = z2-z1;
  const len = Math.sqrt(dx*dx + dz*dz);
  const geo = new THREE.CylinderGeometry(0.04, 0.04, len, 6);
  geo.rotateX(Math.PI/2);
  const mesh = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({ color: 0xa855f7 }));
  mesh.position.set((x1+x2)/2, 0.5, (z1+z2)/2);
  mesh.lookAt(x2, 0.5, z2);
  scene.add(mesh);
  setTimeout(() => scene.remove(mesh), 100);
}

function updateParticles(dt) {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.z += p.vz * dt;
    p.vy -= 15 * dt;
    p.life -= dt;
    if (p.mesh) { p.mesh.position.set(p.x, p.y, p.z); p.mesh.scale.setScalar(p.life * 2); }
    if (p.life <= 0 || p.y < 0) { if (p.mesh) scene.remove(p.mesh); particles.splice(i, 1); }
  }
}

function onResize() {
  resizeRendererToDisplaySize();
}

function closeModal(type) {
  document.getElementById(type + 'Modal').classList.remove('show');
  unbindInputListeners();
  if (resizeObserver) resizeObserver.disconnect();
  selectTheme(theme);
}

document.querySelectorAll('.speed-btn').forEach(btn => {
  btn.onclick = () => {
    gameSpeed = +btn.dataset.speed;
    if (saveData) {
      saveData.settings.gameSpeed = gameSpeed;
      persistSave();
    }
    updateSpeedButtons();
  };
});

document.querySelectorAll('.speed-setting').forEach(btn => {
  btn.onclick = () => {
    gameSpeed = +btn.dataset.speed;
    if (saveData) {
      saveData.settings.gameSpeed = gameSpeed;
      persistSave();
    }
    updateSpeedButtons();
  };
});

const sfxToggle = document.getElementById('sfxToggle');
if (sfxToggle) {
  sfxToggle.onclick = () => {
    if (!saveData) loadSaveData();
    setSfxEnabled(!saveData.settings.sfx);
  };
}

window.addEventListener('beforeunload', () => {
  persistSave();
});

window.addEventListener('pagehide', () => {
  persistSave();
});

document.addEventListener('visibilitychange', () => {
  if (document.visibilityState === 'hidden') persistSave();
});

loadSaveData();
if (saveData && saveData.meta.lastTheme) {
  selectTheme(saveData.meta.lastTheme);
}
</script>
</body>
</html>
